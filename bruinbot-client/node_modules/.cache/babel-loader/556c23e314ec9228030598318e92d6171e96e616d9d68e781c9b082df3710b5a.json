{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, {\n  numeric: 1\n}).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = \"host\";\nconst UPLOAD_URL = \"upload\";\nconst LOGIN_URL = \"login\";\nconst CONFIG_URL = \"config\";\nconst API_INFO_URL = \"info\";\nconst RUNTIME_URL = \"runtime\";\nconst SLEEPTIME_URL = \"sleeptime\";\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...(cookies ? {\n          Cookie: cookies\n        } : {})\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({\n    api_name,\n    id\n  }) => {\n    if (api_name) apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? {\n    Authorization: `Bearer ${this.options.hf_token}`\n  } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return {\n      ...config,\n      path\n    };\n  } else if (endpoint) {\n    const config_url = join_urls(endpoint, CONFIG_URL);\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const {\n    http_protocol,\n    host\n  } = await process_endpoint(this.app_reference, this.options.hf_token);\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(http_protocol, host, this.options.auth, this.fetch, this.options.hf_token);\n      if (cookie_header) this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const {\n      protocol,\n      host,\n      pathname\n    } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst parse_and_set_cookies = cookie_header => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach(cookie => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(`https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`, {\n        headers\n      });\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const {\n      ws_protocol,\n      http_protocol,\n      host\n    } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach(category => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(([endpoint, {\n        parameters,\n        returns\n      }]) => {\n        var _a, _b, _c, _d;\n        const dependencyIndex = ((_a = config.dependencies.find(dep => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\"))) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n        const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find(dep => dep.id == dependencyIndex)) == null ? void 0 : _b.types : {\n          generator: false,\n          cancel: false\n        };\n        if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find(dep => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n          const components = config.dependencies.find(dep => dep.id == dependencyIndex).inputs.map(input => {\n            var _a2;\n            return (_a2 = config.components.find(c => c.id === input)) == null ? void 0 : _a2.type;\n          });\n          try {\n            components.forEach((comp, idx) => {\n              if (comp === \"state\") {\n                const new_param = {\n                  component: \"state\",\n                  example: null,\n                  parameter_default: null,\n                  parameter_has_default: true,\n                  parameter_name: null,\n                  hidden: true\n                };\n                parameters.splice(idx, 0, new_param);\n              }\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        }\n        const transform_type = (data, component, serializer, signature_type) => ({\n          ...data,\n          description: get_description(data == null ? void 0 : data.type, serializer),\n          type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n        });\n        transformed_info[category][endpoint] = {\n          parameters: parameters.map(p => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")),\n          returns: returns.map(r => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")),\n          type: dependencyTypes\n        };\n      });\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return {\n        type: \"data\"\n      };\n    case \"send_hash\":\n      return {\n        type: \"hash\"\n      };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return {\n        type: \"log\",\n        data\n      };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return {\n    type: \"none\",\n    status: {\n      stage: \"error\",\n      queue\n    }\n  };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(`No value provided for required parameter: ${param.parameter_name}`);\n    }\n  });\n  provided_keys.forEach(key => {\n    if (!parameters.some(param => param.parameter_name === key)) {\n      throw new Error(`Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`);\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(`No value provided for required parameter: ${parameters[idx].parameter_name}`);\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info) return this.api_info;\n  const {\n    hf_token\n  } = this.options;\n  const {\n    config\n  } = this;\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    \"Could not get API info. \" + e.message;\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach(file => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return {\n        error: `HTTP ${response.status}: ${error_text}`\n      };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return {\n    files: uploadResponses\n  };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(file_data2 => file_data2.blob);\n  const oversized_files = files.filter(f => f.size > (max_file_size ?? Infinity));\n  if (oversized_files.length) {\n    throw new Error(`File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map(f => f.name).join(\", \")}`);\n  }\n  return await Promise.all(await this.upload_files(root_url, files, upload_id).then(async response => {\n    if (response.error) {\n      throw new Error(response.error);\n    } else {\n      if (response.files) {\n        return response.files.map((f, i) => {\n          const file = new FileData({\n            ...file_data[i],\n            path: f,\n            url: root_url + \"/file=\" + f\n          });\n          return file;\n        });\n      }\n      return [];\n    }\n  }));\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(f => new FileData({\n    path: f.name,\n    orig_name: f.name,\n    blob: f,\n    size: f.size,\n    mime_type: f.type,\n    is_stream\n  }));\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"meta\", {\n      _type: \"gradio.FileData\"\n    });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(data.map(async (_, index) => {\n      var _a;\n      let new_path = path.slice();\n      new_path.push(String(index));\n      const array_refs = await walk_and_store_blobs(data[index], root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type, new_path, false, endpoint_info);\n      blob_refs = blob_refs.concat(array_refs);\n    }));\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [{\n      path,\n      blob: new Blob([data]),\n      type\n    }];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(await walk_and_store_blobs(value, void 0, new_path, false, endpoint_info));\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find(dep => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({\n      data\n    }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: {\n          _type: \"gradio.FileData\"\n        }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\"Invalid input: must be a URL, File, Blob, or Buffer object.\");\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find(c => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(data, void 0, [], true, api_info);\n  const results = await Promise.all(blobRefs.map(async ({\n    path,\n    blob,\n    type\n  }) => {\n    if (!blob) return {\n      path,\n      type\n    };\n    const response = await self.upload_files(endpoint, [blob]);\n    const file_url = response.files && response.files[0];\n    return {\n      path,\n      file_url,\n      type,\n      name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n    };\n  }));\n  results.forEach(({\n    path,\n    file_url,\n    type,\n    name\n  }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({\n        path: file_url,\n        orig_name: name\n      });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await import(\"fs/promises\");\n      const path = await import(\"path\");\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], {\n      type: \"application/octet-stream\"\n    });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: {\n        ...headers,\n        ...additional_headers\n      },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{\n      error: BROKEN_CONNECTION_MSG\n    }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = {\n      error: `Could not parse server response: ${e}`\n    };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find(dep => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(dep => dep.id == this.api_map[trimmed_endpoint]);\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\") reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200) return;\n  const {\n    runtime: {\n      stage\n    },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise(resolve => {\n    check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", status => {\n      status_callback(status);\n      if (status.status === \"running\") {\n        resolve();\n      } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n        resolve();\n      } else if (status.status === \"sleeping\" || status.status === \"building\") {\n        if (retries < max_retries) {\n          retries++;\n          setTimeout(() => {\n            check_and_wake_space(space_id, status_callback).then(resolve);\n          }, check_interval);\n        } else {\n          resolve();\n        }\n      }\n    });\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space_id}/discussions`, {\n      method: \"HEAD\"\n    });\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error)) return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`, {\n      headers\n    });\n    if (res.status !== 200) throw new Error(\"Space hardware could not be obtained.\");\n    const {\n      hardware\n    } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(body)\n    });\n    if (res.status !== 200) {\n      throw new Error(\"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\");\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\"cpu-basic\", \"cpu-upgrade\", \"cpu-xl\", \"t4-small\", \"t4-medium\", \"a10g-small\", \"a10g-large\", \"a10g-largex2\", \"a10g-largex4\", \"a100-large\", \"zero-a10g\", \"h100\", \"h100x8\"];\nasync function duplicate(app_reference, options) {\n  const {\n    hf_token,\n    private: _private,\n    hardware,\n    timeout,\n    auth\n  } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(`Invalid hardware type provided. Valid types are: ${hardware_types.map(v => `\"${v}\"`).join(\",\")}.`);\n  }\n  const {\n    http_protocol,\n    host\n  } = await process_endpoint(app_reference, hf_token);\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(http_protocol, host, auth, fetch);\n    if (cookie_header) cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...(cookies ? {\n      Cookie: cookies.join(\"; \")\n    } : {})\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(`https://huggingface.co/api/spaces/${app_reference}/duplicate`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body)\n    });\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(get_space_reference(duplicated_space.url), options);\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = {\n    allowCR: false\n  }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1) break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: controller => {\n        if (__privateGet(this, _currentLine) === \"\") return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({\n    allowCR: true\n  });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [input.substring(0, idx), input.substring(idx + match[0].length)];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp) headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body) return;\n  let iter = stream$1(res.body);\n  let line,\n    reader = iter.getReader();\n  let event;\n  for (;;) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done) return;\n    if (!line.value) {\n      if (event) yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field) continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok) throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}/queue/data?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function (event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(Object.keys(event_callbacks).map(event_id2 => event_callbacks[event_id2](_data)));\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(config.protocol)) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function () {\n    await Promise.all(Object.keys(event_callbacks).map(event_id => event_callbacks[event_id]({\n      msg: \"unexpected_error\",\n      message: BROKEN_CONNECTION_MSG\n    })));\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async res => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch(e => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function (event) {\n        if (all_events || events_to_publish[event.type]) {\n          push_event(event);\n        }\n      },\n      close = function () {\n        done = true;\n        while (resolvers.length > 0) resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n      },\n      push = function (data2) {\n        if (done) return;\n        if (resolvers.length > 0) {\n          resolvers.shift()(data2);\n        } else {\n          values.push(data2);\n        }\n      },\n      push_error = function (error) {\n        push(thenable_reject(error));\n        close();\n      },\n      push_event = function (event) {\n        push({\n          value: event,\n          done: false\n        });\n      },\n      next = function () {\n        if (values.length > 0) return Promise.resolve(values.shift());\n        if (done) return Promise.resolve({\n          value: void 0,\n          done: true\n        });\n        return new Promise(resolve => resolvers.push(resolve));\n      };\n    const {\n      hf_token\n    } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options\n    } = this;\n    const that = this;\n    if (!api_info) throw new Error(\"No API found\");\n    if (!config) throw new Error(\"Could not resolve app config\");\n    let {\n      fn_index,\n      endpoint_info,\n      dependency\n    } = get_endpoint_info(api_info, endpoint, api_map, config);\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce((acc, event) => {\n      acc[event] = true;\n      return acc;\n    }, {})) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = {\n          fn_index,\n          session_hash\n        };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = {\n          event_id\n        };\n        cancel_request = {\n          event_id,\n          session_hash,\n          fn_index\n        };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}/cancel`, {\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}/reset`, {\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\");\n      }\n    }\n    const resolve_heartbeat = async config2 => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config) return;\n      let render_id = render_config.render_id;\n      config.components = [...config.components.filter(c => c.props.rendered_in !== render_id), ...render_config.components];\n      config.dependencies = [...config.dependencies.filter(d => d.rendered_in !== render_id), ...render_config.dependencies];\n      const any_state = config.components.some(c => c.type === \"state\");\n      const any_unload = config.dependencies.some(d => d.targets.some(t => t[1] === \"unload\"));\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(async _payload => {\n      var _a2;\n      let input_data = handle_payload(_payload, dependency, config.components, \"input\", true);\n      payload = {\n        data: input_data || [],\n        event_data,\n        fn_index,\n        trigger_id\n      };\n      if (skip_queue(fn_index, config)) {\n        fire_event({\n          type: \"status\",\n          endpoint: _endpoint,\n          stage: \"pending\",\n          queue: false,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        post_data2(`${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`, {\n          ...payload,\n          session_hash\n        }).then(([output, status_code]) => {\n          const data2 = output.data;\n          if (status_code == 200) {\n            fire_event({\n              type: \"data\",\n              endpoint: _endpoint,\n              fn_index,\n              data: handle_payload(data2, dependency, config.components, \"output\", options.with_null_state),\n              time: /* @__PURE__ */new Date(),\n              event_data,\n              trigger_id\n            });\n            if (output.render_config) {\n              handle_render_config(output.render_config);\n            }\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              stage: \"complete\",\n              eta: output.average_duration,\n              queue: false,\n              time: /* @__PURE__ */new Date()\n            });\n          } else {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              endpoint: _endpoint,\n              fn_index,\n              message: output.error,\n              queue: false,\n              time: /* @__PURE__ */new Date()\n            });\n          }\n        }).catch(e => {\n          fire_event({\n            type: \"status\",\n            stage: \"error\",\n            message: e.message,\n            endpoint: _endpoint,\n            fn_index,\n            queue: false,\n            time: /* @__PURE__ */new Date()\n          });\n        });\n      } else if (protocol == \"ws\") {\n        const {\n          ws_protocol,\n          host\n        } = await process_endpoint(app_reference, hf_token);\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        let url = new URL(`${ws_protocol}://${resolve_root(host, config.path, true)}/queue/join${url_params ? \"?\" + url_params : \"\"}`);\n        if (this.jwt) {\n          url.searchParams.set(\"__sign\", this.jwt);\n        }\n        websocket = new WebSocket(url);\n        websocket.onclose = evt => {\n          if (!evt.wasClean) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              broken: true,\n              message: BROKEN_CONNECTION_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          }\n        };\n        websocket.onmessage = function (event) {\n          const _data = JSON.parse(event.data);\n          const {\n            type,\n            status,\n            data: data2\n          } = handle_message(_data, last_status[fn_index]);\n          if (type === \"update\" && status && !complete) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date(),\n              ...status\n            });\n            if (status.stage === \"error\") {\n              websocket.close();\n            }\n          } else if (type === \"hash\") {\n            websocket.send(JSON.stringify({\n              fn_index,\n              session_hash\n            }));\n            return;\n          } else if (type === \"data\") {\n            websocket.send(JSON.stringify({\n              ...payload,\n              session_hash\n            }));\n          } else if (type === \"complete\") {\n            complete = status;\n          } else if (type === \"log\") {\n            fire_event({\n              type: \"log\",\n              log: data2.log,\n              level: data2.level,\n              endpoint: _endpoint,\n              duration: data2.duration,\n              visible: data2.visible,\n              fn_index\n            });\n          } else if (type === \"generating\") {\n            fire_event({\n              type: \"status\",\n              time: /* @__PURE__ */new Date(),\n              ...status,\n              stage: status == null ? void 0 : status.stage,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index\n            });\n          }\n          if (data2) {\n            fire_event({\n              type: \"data\",\n              time: /* @__PURE__ */new Date(),\n              data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n              endpoint: _endpoint,\n              fn_index,\n              event_data,\n              trigger_id\n            });\n            if (complete) {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */new Date(),\n                ...complete,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n              websocket.close();\n            }\n          }\n        };\n        if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n          addEventListener(\"open\", () => websocket.send(JSON.stringify({\n            hash: session_hash\n          })));\n        }\n      } else if (protocol == \"sse\") {\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        var params = new URLSearchParams({\n          fn_index: fn_index.toString(),\n          session_hash\n        }).toString();\n        let url = new URL(`${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`);\n        if (this.jwt) {\n          url.searchParams.set(\"__sign\", this.jwt);\n        }\n        stream2 = this.stream(url);\n        if (!stream2) {\n          return Promise.reject(new Error(\"Cannot connect to SSE endpoint: \" + url.toString()));\n        }\n        stream2.onmessage = async function (event) {\n          const _data = JSON.parse(event.data);\n          const {\n            type,\n            status,\n            data: data2\n          } = handle_message(_data, last_status[fn_index]);\n          if (type === \"update\" && status && !complete) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date(),\n              ...status\n            });\n            if (status.stage === \"error\") {\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          } else if (type === \"data\") {\n            event_id = _data.event_id;\n            let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n              ...payload,\n              session_hash,\n              event_id\n            });\n            if (status2 !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */new Date()\n              });\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          } else if (type === \"complete\") {\n            complete = status;\n          } else if (type === \"log\") {\n            fire_event({\n              type: \"log\",\n              log: data2.log,\n              level: data2.level,\n              endpoint: _endpoint,\n              duration: data2.duration,\n              visible: data2.visible,\n              fn_index\n            });\n          } else if (type === \"generating\") {\n            fire_event({\n              type: \"status\",\n              time: /* @__PURE__ */new Date(),\n              ...status,\n              stage: status == null ? void 0 : status.stage,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index\n            });\n          }\n          if (data2) {\n            fire_event({\n              type: \"data\",\n              time: /* @__PURE__ */new Date(),\n              data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n              endpoint: _endpoint,\n              fn_index,\n              event_data,\n              trigger_id\n            });\n            if (complete) {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */new Date(),\n                ...complete,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          }\n        };\n      } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        let hostname = \"\";\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n          hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n        }\n        let hfhubdev = \"dev.spaces.huggingface.tech\";\n        const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n        const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\n        const is_zerogpu_space = dependency.zerogpu && config.space_id;\n        const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n        const post_data_promise = zerogpu_auth_promise.then(headers => {\n          return post_data2(`${config.root}/queue/join?${url_params}`, {\n            ...payload,\n            session_hash\n          }, headers);\n        });\n        post_data_promise.then(async ([response, status]) => {\n          if (status === 503) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: QUEUE_FULL_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          } else if (status !== 200) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: BROKEN_CONNECTION_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          } else {\n            event_id = response.event_id;\n            let callback = async function (_data) {\n              try {\n                const {\n                  type,\n                  status: status2,\n                  data: data2\n                } = handle_message(_data, last_status[fn_index]);\n                if (type == \"heartbeat\") {\n                  return;\n                }\n                if (type === \"update\" && status2 && !complete) {\n                  fire_event({\n                    type: \"status\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date(),\n                    ...status2\n                  });\n                } else if (type === \"complete\") {\n                  complete = status2;\n                } else if (type == \"unexpected_error\") {\n                  console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date()\n                  });\n                } else if (type === \"log\") {\n                  fire_event({\n                    type: \"log\",\n                    log: data2.log,\n                    level: data2.level,\n                    endpoint: _endpoint,\n                    duration: data2.duration,\n                    visible: data2.visible,\n                    fn_index\n                  });\n                  return;\n                } else if (type === \"generating\") {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */new Date(),\n                    ...status2,\n                    stage: status2 == null ? void 0 : status2.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (data2 && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    apply_diff_stream(pending_diff_streams, event_id, data2);\n                  }\n                }\n                if (data2) {\n                  fire_event({\n                    type: \"data\",\n                    time: /* @__PURE__ */new Date(),\n                    data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (data2.render_config) {\n                    await handle_render_config(data2.render_config);\n                  }\n                  if (complete) {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */new Date(),\n                      ...complete,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    close();\n                  }\n                }\n                if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                  if (event_callbacks[event_id]) {\n                    delete event_callbacks[event_id];\n                  }\n                  if (event_id in pending_diff_streams) {\n                    delete pending_diff_streams[event_id];\n                  }\n                }\n              } catch (e) {\n                console.error(\"Unexpected client exception\", e);\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: \"An Unexpected Error Occurred!\",\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date()\n                });\n                if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                  close_stream(stream_status, that.abort_controller);\n                  stream_status.open = false;\n                  close();\n                }\n              }\n            };\n            if (event_id in pending_stream_messages) {\n              pending_stream_messages[event_id].forEach(msg => callback(msg));\n              delete pending_stream_messages[event_id];\n            }\n            event_callbacks[event_id] = callback;\n            unclosed_events.add(event_id);\n            if (!stream_status.open) {\n              await this.open_stream();\n            }\n          }\n        });\n      }\n    });\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async value => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find(dep => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(dep => dep.id == api_map[trimmed_endpoint]);\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\"There is no endpoint matching that name of fn_index matching that number.\");\n  }\n  return {\n    fn_index,\n    endpoint_info,\n    dependency\n  };\n}\nclass Client {\n  constructor(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", {\n      open: false\n    });\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    this.app_reference = app_reference;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    return fetch(input, {\n      ...init,\n      headers\n    });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await import(\"./wrapper-CviSselG.js\");\n      global.WebSocket = ws.WebSocket;\n    }\n    try {\n      if (this.options.auth) {\n        await this.resolve_cookies();\n      }\n      await this._resolve_config().then(({\n        config\n      }) => this._resolve_hearbeat(config));\n    } catch (e) {\n      throw Error(e);\n    }\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(this.config.space_id, this.options.hf_token, this.cookies);\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(`${this.config.root}/heartbeat/${this.session_hash}`);\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const {\n      http_protocol,\n      host,\n      space_id\n    } = await process_endpoint(this.app_reference, this.options.hf_token);\n    const {\n      status_callback\n    } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      config = await this.resolve_config(`${http_protocol}//${host}`);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", this.handle_space_success);\n      } else {\n        if (status_callback) status_callback({\n          status: \"error\",\n          message: \"Could not load this space.\",\n          load_status: \"error\",\n          detail: \"NOT_FOUND\"\n        });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const {\n      status_callback\n    } = this.options;\n    if (status_callback) status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const {\n      hf_token\n    } = this.options;\n    const {\n      session_hash\n    } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(comp => comp.id === component_id);\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\") continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(`${root_url}/component_server/`, {\n        method: \"POST\",\n        body,\n        headers,\n        credentials: \"include\"\n      });\n      if (!response.ok) {\n        throw new Error(\"Could not connect to component server: \" + response.statusText);\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\nexport { Client, FileData, client, duplicate_space as duplicate, handle_file, predict, prepare_files, submit, upload, upload_files };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","__accessCheck","member","msg","has","TypeError","__privateGet","getter","call","get","__privateAdd","WeakSet","add","set","__privateSet","setter","_currentLine","fn","Intl","Collator","numeric","compare","semiver","a","b","bool","split","slice","join","test","HOST_URL","UPLOAD_URL","LOGIN_URL","CONFIG_URL","API_INFO_URL","RUNTIME_URL","SLEEPTIME_URL","SPACE_FETCHER_URL","QUEUE_FULL_MSG","BROKEN_CONNECTION_MSG","CONFIG_ERROR_MSG","SPACE_STATUS_ERROR_MSG","API_INFO_ERROR_MSG","SPACE_METADATA_ERROR_MSG","INVALID_URL_MSG","UNAUTHORIZED_MSG","INVALID_CREDENTIALS_MSG","MISSING_CREDENTIALS_MSG","NODEJS_FS_ERROR_MSG","ROOT_URL_ERROR_MSG","FILE_PROCESSING_ERROR_MSG","resolve_root","base_url","root_path","prioritize_base","startsWith","get_jwt","space","token","cookies","r","fetch","headers","Authorization","Cookie","jwt","json","e","map_names_to_ids","fns","apis","forEach","api_name","id","resolve_config","endpoint","_a","options","hf_token","window","gradio_config","location","origin","dev_mode","path","root","config","config_root","config_url","join_urls","response","credentials","status","auth","Error","dependencies","dep","i","resolve_cookies","http_protocol","host","process_endpoint","app_reference","cookie_header","get_cookie_header","set_cookies","message","_fetch","formData","FormData","append","res","method","body","determine_protocol","protocol","pathname","URL","endsWith","ws_protocol","parse_and_set_cookies","parts","cookie","cookie_name","cookie_value","push","trim","RE_SPACE_NAME","RE_SPACE_DOMAIN","_app_reference","replace","_host","space_id","urls","reduce","part","toString","transform_api_info","api_info","api_map","transformed_info","named_endpoints","unnamed_endpoints","keys","category","entries","parameters","returns","_b","_c","_d","dependencyIndex","find","dependencyTypes","types","generator","cancel","inputs","length","components","map","input","_a2","c","type","comp","idx","new_param","component","example","parameter_default","parameter_has_default","parameter_name","hidden","splice","console","error","transform_type","data","serializer","signature_type","description","get_description","get_type","p","handle_message","last_status","queue","stage","code","success","size","queue_size","position","rank","eta","rank_eta","progress_data","output","average_duration","visible","duration","changed_state_ids","map_data_to_params","endpoint_info","Array","isArray","warn","resolved_data","provided_keys","param","index","hasOwnProperty","some","view_api","gradio_api_info","version","JSON","stringify","serialize","url","ok","api","upload_files","root_url","files","upload_id","chunkSize","uploadResponses","chunk","file","upload_url","error_text","text","upload","file_data","max_file_size","file_data2","blob","oversized_files","filter","f","Infinity","name","Promise","all","then","FileData","prepare_files","is_stream","orig_name","mime_type","constructor","alt_text","_type","Command","command","meta","is_node","process","versions","node","update_object","object","newValue","stack","key2","shift","walk_and_store_blobs","blob_refs","_","new_path","String","array_refs","concat","globalThis","Buffer","Blob","skip_queue","fn_queue","enable_queue","post_message","_rej","channel","MessageChannel","port1","onmessage","close","parent","postMessage","port2","handle_file","file_or_url","pop","orig_path","File","handle_payload","resolved_payload","dependency","with_null_state","updated_payload","payload_index","deps","outputs","input_id","handle_blob","self","process_local_file_commands","blobRefs","results","file_url","client2","recursively_process_commands","process_single_command","cmd_item","fileBuffer","fullPath","fs","resolve","cwd","readFile","fileData","post_data","additional_headers","predict","data_returned","status_complete","trimmed_endpoint","reject","app","submit","result","check_space_status","status_callback","_status","load_status","detail","runtime","space_name","setTimeout","discussions_enabled","check_and_wake_space","retries","max_retries","check_interval","RE_DISABLED_DISCUSSION","get_space_hardware","hardware","current","set_space_timeout","timeout","seconds","hardware_types","duplicate","private","_private","includes","v","user","repository","original_hardware","requested_hardware","Client","connect","statusText","duplicated_space","get_space_reference","regex","match","TextLineStream","TransformStream","allowCR","transform","chars","controller","lfIndex","indexOf","crIndex","enqueue","endIndex","flush","currentLine","WeakMap","stream$1","decoder","TextDecoderStream","split2","pipeThrough","rgx","exec","substring","fallback","tmp","events","signal","iter","line","reader","getReader","event","aborted","read","done","field","stream","init","req","Request","open_stream","event_callbacks","unclosed_events","pending_stream_messages","stream_status","that","open","stream2","params","URLSearchParams","session_hash","searchParams","_data","parse","close_stream","abort_controller","event_id","event_id2","delete","fn2","document","onerror","abort","apply_diff_stream","pending_diff_streams","is_first_generation","new_data","apply_diff","diff","action","apply_edit","target","last_path","Number","readable_stream","instance","onopen","readyState","withCredentials","CONNECTING","OPEN","CLOSED","addEventListener","dispatchEvent","removeEventListener","catch","event_data","trigger_id","all_events","fire_event","events_to_publish","push_event","resolvers","data2","values","push_error","thenable_reject","next","fetch2","post_data2","fn_index","get_endpoint_info","websocket","_endpoint","payload","complete","url_params","search","acc","time","Date","reset_request","cancel_request","resolve_heartbeat","config2","_resolve_hearbeat","handle_render_config","render_config","render_id","props","rendered_in","d","any_state","any_unload","targets","t","connect_heartbeat","_payload","input_data","status_code","WebSocket","onclose","evt","wasClean","broken","send","log","level","hash","status2","hostname","hfhubdev","is_iframe","is_zerogpu_space","zerogpu","zerogpu_auth_promise","post_data_promise","callback","iterator","Symbol","asyncIterator","throw","return","Math","random","Set","bind","handle_space_success","Headers","AbortController","stream_instance","global","ws","_resolve_config","_config","heartbeat_url","heartbeat_event","config_success","auth_required","prepare_return_obj","component_server","component_id","fn_name","raw_cookies","client","duplicate_space"],"sources":["/Users/ananyaanand/Desktop/bruinbot/node_modules/@gradio/client/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, { numeric: 1 }).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = \"host\";\nconst UPLOAD_URL = \"upload\";\nconst LOGIN_URL = \"login\";\nconst CONFIG_URL = \"config\";\nconst API_INFO_URL = \"info\";\nconst RUNTIME_URL = \"runtime\";\nconst SLEEPTIME_URL = \"sleeptime\";\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...cookies ? { Cookie: cookies } : {}\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({ api_name, id }) => {\n    if (api_name)\n      apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return { ...config, path };\n  } else if (endpoint) {\n    const config_url = join_urls(endpoint, CONFIG_URL);\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const { http_protocol, host } = await process_endpoint(\n    this.app_reference,\n    this.options.hf_token\n  );\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(\n        http_protocol,\n        host,\n        this.options.auth,\n        this.fetch,\n        this.options.hf_token\n      );\n      if (cookie_header)\n        this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const { protocol, host, pathname } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst parse_and_set_cookies = (cookie_header) => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach((cookie) => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(\n        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,\n        { headers }\n      );\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach((category) => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(\n        ([endpoint, { parameters, returns }]) => {\n          var _a, _b, _c, _d;\n          const dependencyIndex = ((_a = config.dependencies.find(\n            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\")\n          )) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };\n          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(\n              (input) => {\n                var _a2;\n                return (_a2 = config.components.find((c) => c.id === input)) == null ? void 0 : _a2.type;\n              }\n            );\n            try {\n              components.forEach((comp, idx) => {\n                if (comp === \"state\") {\n                  const new_param = {\n                    component: \"state\",\n                    example: null,\n                    parameter_default: null,\n                    parameter_has_default: true,\n                    parameter_name: null,\n                    hidden: true\n                  };\n                  parameters.splice(idx, 0, new_param);\n                }\n              });\n            } catch (e) {\n              console.error(e);\n            }\n          }\n          const transform_type = (data, component, serializer, signature_type) => ({\n            ...data,\n            description: get_description(data == null ? void 0 : data.type, serializer),\n            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n          });\n          transformed_info[category][endpoint] = {\n            parameters: parameters.map(\n              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")\n            ),\n            returns: returns.map(\n              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")\n            ),\n            type: dependencyTypes\n          };\n        }\n      );\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return { type: \"log\", data };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return { type: \"none\", status: { stage: \"error\", queue } };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(\n        `No value provided for required parameter: ${param.parameter_name}`\n      );\n    }\n  });\n  provided_keys.forEach((key) => {\n    if (!parameters.some((param) => param.parameter_name === key)) {\n      throw new Error(\n        `Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`\n      );\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(\n        `No value provided for required parameter: ${parameters[idx].parameter_name}`\n      );\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info)\n    return this.api_info;\n  const { hf_token } = this.options;\n  const { config } = this;\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    \"Could not get API info. \" + e.message;\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach((file) => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return { error: `HTTP ${response.status}: ${error_text}` };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return { files: uploadResponses };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\n    (file_data2) => file_data2.blob\n  );\n  const oversized_files = files.filter(\n    (f) => f.size > (max_file_size ?? Infinity)\n  );\n  if (oversized_files.length) {\n    throw new Error(\n      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(\", \")}`\n    );\n  }\n  return await Promise.all(\n    await this.upload_files(root_url, files, upload_id).then(\n      async (response) => {\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          if (response.files) {\n            return response.files.map((f, i) => {\n              const file = new FileData({\n                ...file_data[i],\n                path: f,\n                url: root_url + \"/file=\" + f\n              });\n              return file;\n            });\n          }\n          return [];\n        }\n      }\n    )\n  );\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(\n    (f) => new FileData({\n      path: f.name,\n      orig_name: f.name,\n      blob: f,\n      size: f.size,\n      mime_type: f.type,\n      is_stream\n    })\n  );\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"meta\", { _type: \"gradio.FileData\" });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(\n      data.map(async (_, index) => {\n        var _a;\n        let new_path = path.slice();\n        new_path.push(String(index));\n        const array_refs = await walk_and_store_blobs(\n          data[index],\n          root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type,\n          new_path,\n          false,\n          endpoint_info\n        );\n        blob_refs = blob_refs.concat(array_refs);\n      })\n    );\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [\n      {\n        path,\n        blob: new Blob([data]),\n        type\n      }\n    ];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(\n        await walk_and_store_blobs(\n          value,\n          void 0,\n          new_path,\n          false,\n          endpoint_info\n        )\n      );\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find((dep) => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({ data }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: { _type: \"gradio.FileData\" }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\n    \"Invalid input: must be a URL, File, Blob, or Buffer object.\"\n  );\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find((c) => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(\n    data,\n    void 0,\n    [],\n    true,\n    api_info\n  );\n  const results = await Promise.all(\n    blobRefs.map(async ({ path, blob, type }) => {\n      if (!blob)\n        return { path, type };\n      const response = await self.upload_files(endpoint, [blob]);\n      const file_url = response.files && response.files[0];\n      return {\n        path,\n        file_url,\n        type,\n        name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n      };\n    })\n  );\n  results.forEach(({ path, file_url, type, name }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({ path: file_url, orig_name: name });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await import(\"fs/promises\");\n      const path = await import(\"path\");\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], { type: \"application/octet-stream\" });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: { ...headers, ...additional_headers },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{ error: BROKEN_CONNECTION_MSG }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = { error: `Could not parse server response: ${e}` };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(\n      (dep) => dep.id == this.api_map[trimmed_endpoint]\n    );\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\")\n          reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200)\n    return;\n  const {\n    runtime: { stage },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise((resolve) => {\n    check_space_status(\n      space_id,\n      RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n      (status) => {\n        status_callback(status);\n        if (status.status === \"running\") {\n          resolve();\n        } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n          resolve();\n        } else if (status.status === \"sleeping\" || status.status === \"building\") {\n          if (retries < max_retries) {\n            retries++;\n            setTimeout(() => {\n              check_and_wake_space(space_id, status_callback).then(resolve);\n            }, check_interval);\n          } else {\n            resolve();\n          }\n        }\n      }\n    );\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    );\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))\n      return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,\n      { headers }\n    );\n    if (res.status !== 200)\n      throw new Error(\"Space hardware could not be obtained.\");\n    const { hardware } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify(body)\n      }\n    );\n    if (res.status !== 200) {\n      throw new Error(\n        \"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\"\n      );\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\n  \"cpu-basic\",\n  \"cpu-upgrade\",\n  \"cpu-xl\",\n  \"t4-small\",\n  \"t4-medium\",\n  \"a10g-small\",\n  \"a10g-large\",\n  \"a10g-largex2\",\n  \"a10g-largex4\",\n  \"a100-large\",\n  \"zero-a10g\",\n  \"h100\",\n  \"h100x8\"\n];\nasync function duplicate(app_reference, options) {\n  const { hf_token, private: _private, hardware, timeout, auth } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\n    );\n  }\n  const { http_protocol, host } = await process_endpoint(\n    app_reference,\n    hf_token\n  );\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(\n      http_protocol,\n      host,\n      auth,\n      fetch\n    );\n    if (cookie_header)\n      cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...cookies ? { Cookie: cookies.join(\"; \") } : {}\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\n      {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n      }\n    );\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(\n      get_space_reference(duplicated_space.url),\n      options\n    );\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = { allowCR: false }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1)\n            break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: (controller) => {\n        if (__privateGet(this, _currentLine) === \"\")\n          return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({ allowCR: true });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [\n      input.substring(0, idx),\n      input.substring(idx + match[0].length)\n    ];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp)\n    headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body)\n    return;\n  let iter = stream$1(res.body);\n  let line, reader = iter.getReader();\n  let event;\n  for (; ; ) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done)\n      return;\n    if (!line.value) {\n      if (event)\n        yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field)\n      continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok)\n    throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}/queue/data?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function(event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(\n        Object.keys(event_callbacks).map(\n          (event_id2) => event_callbacks[event_id2](_data)\n        )\n      );\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(\n        config.protocol\n      )) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function() {\n    await Promise.all(\n      Object.keys(event_callbacks).map(\n        (event_id) => event_callbacks[event_id]({\n          msg: \"unexpected_error\",\n          message: BROKEN_CONNECTION_MSG\n        })\n      )\n    );\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async (res) => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch((e) => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function(event) {\n      if (all_events || events_to_publish[event.type]) {\n        push_event(event);\n      }\n    }, close = function() {\n      done = true;\n      while (resolvers.length > 0)\n        resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n    }, push = function(data2) {\n      if (done)\n        return;\n      if (resolvers.length > 0) {\n        resolvers.shift()(data2);\n      } else {\n        values.push(data2);\n      }\n    }, push_error = function(error) {\n      push(thenable_reject(error));\n      close();\n    }, push_event = function(event) {\n      push({ value: event, done: false });\n    }, next = function() {\n      if (values.length > 0)\n        return Promise.resolve(values.shift());\n      if (done)\n        return Promise.resolve({ value: void 0, done: true });\n      return new Promise((resolve) => resolvers.push(resolve));\n    };\n    const { hf_token } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options\n    } = this;\n    const that = this;\n    if (!api_info)\n      throw new Error(\"No API found\");\n    if (!config)\n      throw new Error(\"Could not resolve app config\");\n    let { fn_index, endpoint_info, dependency } = get_endpoint_info(\n      api_info,\n      endpoint,\n      api_map,\n      config\n    );\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce(\n      (acc, event) => {\n        acc[event] = true;\n        return acc;\n      },\n      {}\n    )) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */ new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = { fn_index, session_hash };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = { event_id };\n        cancel_request = { event_id, session_hash, fn_index };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}/cancel`, {\n            headers: { \"Content-Type\": \"application/json\" },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}/reset`, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\n          \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\n        );\n      }\n    }\n    const resolve_heartbeat = async (config2) => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config)\n        return;\n      let render_id = render_config.render_id;\n      config.components = [\n        ...config.components.filter((c) => c.props.rendered_in !== render_id),\n        ...render_config.components\n      ];\n      config.dependencies = [\n        ...config.dependencies.filter((d) => d.rendered_in !== render_id),\n        ...render_config.dependencies\n      ];\n      const any_state = config.components.some((c) => c.type === \"state\");\n      const any_unload = config.dependencies.some(\n        (d) => d.targets.some((t) => t[1] === \"unload\")\n      );\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(\n      async (_payload) => {\n        var _a2;\n        let input_data = handle_payload(\n          _payload,\n          dependency,\n          config.components,\n          \"input\",\n          true\n        );\n        payload = {\n          data: input_data || [],\n          event_data,\n          fn_index,\n          trigger_id\n        };\n        if (skip_queue(fn_index, config)) {\n          fire_event({\n            type: \"status\",\n            endpoint: _endpoint,\n            stage: \"pending\",\n            queue: false,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          post_data2(\n            `${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\n            {\n              ...payload,\n              session_hash\n            }\n          ).then(([output, status_code]) => {\n            const data2 = output.data;\n            if (status_code == 200) {\n              fire_event({\n                type: \"data\",\n                endpoint: _endpoint,\n                fn_index,\n                data: handle_payload(\n                  data2,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                time: /* @__PURE__ */ new Date(),\n                event_data,\n                trigger_id\n              });\n              if (output.render_config) {\n                handle_render_config(output.render_config);\n              }\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                stage: \"complete\",\n                eta: output.average_duration,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                endpoint: _endpoint,\n                fn_index,\n                message: output.error,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          }).catch((e) => {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: e.message,\n              endpoint: _endpoint,\n              fn_index,\n              queue: false,\n              time: /* @__PURE__ */ new Date()\n            });\n          });\n        } else if (protocol == \"ws\") {\n          const { ws_protocol, host } = await process_endpoint(\n            app_reference,\n            hf_token\n          );\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let url = new URL(\n            `${ws_protocol}://${resolve_root(\n              host,\n              config.path,\n              true\n            )}/queue/join${url_params ? \"?\" + url_params : \"\"}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          websocket = new WebSocket(url);\n          websocket.onclose = (evt) => {\n            if (!evt.wasClean) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                broken: true,\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          };\n          websocket.onmessage = function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                websocket.close();\n              }\n            } else if (type === \"hash\") {\n              websocket.send(JSON.stringify({ fn_index, session_hash }));\n              return;\n            } else if (type === \"data\") {\n              websocket.send(JSON.stringify({ ...payload, session_hash }));\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                websocket.close();\n              }\n            }\n          };\n          if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n            addEventListener(\n              \"open\",\n              () => websocket.send(JSON.stringify({ hash: session_hash }))\n            );\n          }\n        } else if (protocol == \"sse\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          var params = new URLSearchParams({\n            fn_index: fn_index.toString(),\n            session_hash\n          }).toString();\n          let url = new URL(\n            `${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          stream2 = this.stream(url);\n          if (!stream2) {\n            return Promise.reject(\n              new Error(\"Cannot connect to SSE endpoint: \" + url.toString())\n            );\n          }\n          stream2.onmessage = async function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"data\") {\n              event_id = _data.event_id;\n              let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n                ...payload,\n                session_hash,\n                event_id\n              });\n              if (status2 !== 200) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */ new Date()\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            }\n          };\n        } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let hostname = \"\";\n          if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n            hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n          }\n          let hfhubdev = \"dev.spaces.huggingface.tech\";\n          const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n          const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\n          const is_zerogpu_space = dependency.zerogpu && config.space_id;\n          const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n          const post_data_promise = zerogpu_auth_promise.then((headers) => {\n            return post_data2(\n              `${config.root}/queue/join?${url_params}`,\n              {\n                ...payload,\n                session_hash\n              },\n              headers\n            );\n          });\n          post_data_promise.then(async ([response, status]) => {\n            if (status === 503) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: QUEUE_FULL_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else if (status !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              event_id = response.event_id;\n              let callback = async function(_data) {\n                try {\n                  const { type, status: status2, data: data2 } = handle_message(\n                    _data,\n                    last_status[fn_index]\n                  );\n                  if (type == \"heartbeat\") {\n                    return;\n                  }\n                  if (type === \"update\" && status2 && !complete) {\n                    fire_event({\n                      type: \"status\",\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2\n                    });\n                  } else if (type === \"complete\") {\n                    complete = status2;\n                  } else if (type == \"unexpected_error\") {\n                    console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date()\n                    });\n                  } else if (type === \"log\") {\n                    fire_event({\n                      type: \"log\",\n                      log: data2.log,\n                      level: data2.level,\n                      endpoint: _endpoint,\n                      duration: data2.duration,\n                      visible: data2.visible,\n                      fn_index\n                    });\n                    return;\n                  } else if (type === \"generating\") {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2 && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                      apply_diff_stream(pending_diff_streams, event_id, data2);\n                    }\n                  }\n                  if (data2) {\n                    fire_event({\n                      type: \"data\",\n                      time: /* @__PURE__ */ new Date(),\n                      data: handle_payload(\n                        data2.data,\n                        dependency,\n                        config.components,\n                        \"output\",\n                        options.with_null_state\n                      ),\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2.render_config) {\n                      await handle_render_config(data2.render_config);\n                    }\n                    if (complete) {\n                      fire_event({\n                        type: \"status\",\n                        time: /* @__PURE__ */ new Date(),\n                        ...complete,\n                        stage: status2 == null ? void 0 : status2.stage,\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      close();\n                    }\n                  }\n                  if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                    if (event_callbacks[event_id]) {\n                      delete event_callbacks[event_id];\n                    }\n                    if (event_id in pending_diff_streams) {\n                      delete pending_diff_streams[event_id];\n                    }\n                  }\n                } catch (e) {\n                  console.error(\"Unexpected client exception\", e);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                  if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    close_stream(stream_status, that.abort_controller);\n                    stream_status.open = false;\n                    close();\n                  }\n                }\n              };\n              if (event_id in pending_stream_messages) {\n                pending_stream_messages[event_id].forEach(\n                  (msg) => callback(msg)\n                );\n                delete pending_stream_messages[event_id];\n              }\n              event_callbacks[event_id] = callback;\n              unclosed_events.add(event_id);\n              if (!stream_status.open) {\n                await this.open_stream();\n              }\n            }\n          });\n        }\n      }\n    );\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async (value) => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(\n      (dep) => dep.id == api_map[trimmed_endpoint]\n    );\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\n      \"There is no endpoint matching that name of fn_index matching that number.\"\n    );\n  }\n  return { fn_index, endpoint_info, dependency };\n}\nclass Client {\n  constructor(app_reference, options = { events: [\"data\"] }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", { open: false });\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */ new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    this.app_reference = app_reference;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    return fetch(input, { ...init, headers });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await import(\"./wrapper-CviSselG.js\");\n      global.WebSocket = ws.WebSocket;\n    }\n    try {\n      if (this.options.auth) {\n        await this.resolve_cookies();\n      }\n      await this._resolve_config().then(\n        ({ config }) => this._resolve_hearbeat(config)\n      );\n    } catch (e) {\n      throw Error(e);\n    }\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(\n            this.config.space_id,\n            this.options.hf_token,\n            this.cookies\n          );\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(\n        `${this.config.root}/heartbeat/${this.session_hash}`\n      );\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const { http_protocol, host, space_id } = await process_endpoint(\n      this.app_reference,\n      this.options.hf_token\n    );\n    const { status_callback } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      config = await this.resolve_config(`${http_protocol}//${host}`);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(\n          space_id,\n          RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n          this.handle_space_success\n        );\n      } else {\n        if (status_callback)\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const { status_callback } = this.options;\n    if (status_callback)\n      status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const { hf_token } = this.options;\n    const { session_hash } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(\n      (comp) => comp.id === component_id\n    );\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\")\n          continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(`${root_url}/component_server/`, {\n        method: \"POST\",\n        body,\n        headers,\n        credentials: \"include\"\n      });\n      if (!response.ok) {\n        throw new Error(\n          \"Could not connect to component server: \" + response.statusText\n        );\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\nexport {\n  Client,\n  FileData,\n  client,\n  duplicate_space as duplicate,\n  handle_file,\n  predict,\n  prepare_files,\n  submit,\n  upload,\n  upload_files\n};\n"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,MAAM,CAACC,cAAc;AACrC,IAAIC,eAAe,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAKD,GAAG,IAAID,GAAG,GAAGJ,SAAS,CAACI,GAAG,EAAEC,GAAG,EAAE;EAAEE,UAAU,EAAE,IAAI;EAAEC,YAAY,EAAE,IAAI;EAAEC,QAAQ,EAAE,IAAI;EAAEH;AAAM,CAAC,CAAC,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;AAC/J,IAAII,aAAa,GAAGA,CAACN,GAAG,EAAEC,GAAG,EAAEC,KAAK,KAAK;EACvCH,eAAe,CAACC,GAAG,EAAE,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAG,EAAE,GAAGA,GAAG,EAAEC,KAAK,CAAC;EACrE,OAAOA,KAAK;AACd,CAAC;AACD,IAAIK,aAAa,GAAGA,CAACP,GAAG,EAAEQ,MAAM,EAAEC,GAAG,KAAK;EACxC,IAAI,CAACD,MAAM,CAACE,GAAG,CAACV,GAAG,CAAC,EAClB,MAAMW,SAAS,CAAC,SAAS,GAAGF,GAAG,CAAC;AACpC,CAAC;AACD,IAAIG,YAAY,GAAGA,CAACZ,GAAG,EAAEQ,MAAM,EAAEK,MAAM,KAAK;EAC1CN,aAAa,CAACP,GAAG,EAAEQ,MAAM,EAAE,yBAAyB,CAAC;EACrD,OAAOK,MAAM,GAAGA,MAAM,CAACC,IAAI,CAACd,GAAG,CAAC,GAAGQ,MAAM,CAACO,GAAG,CAACf,GAAG,CAAC;AACpD,CAAC;AACD,IAAIgB,YAAY,GAAGA,CAAChB,GAAG,EAAEQ,MAAM,EAAEN,KAAK,KAAK;EACzC,IAAIM,MAAM,CAACE,GAAG,CAACV,GAAG,CAAC,EACjB,MAAMW,SAAS,CAAC,mDAAmD,CAAC;EACtEH,MAAM,YAAYS,OAAO,GAAGT,MAAM,CAACU,GAAG,CAAClB,GAAG,CAAC,GAAGQ,MAAM,CAACW,GAAG,CAACnB,GAAG,EAAEE,KAAK,CAAC;AACtE,CAAC;AACD,IAAIkB,YAAY,GAAGA,CAACpB,GAAG,EAAEQ,MAAM,EAAEN,KAAK,EAAEmB,MAAM,KAAK;EACjDd,aAAa,CAACP,GAAG,EAAEQ,MAAM,EAAE,wBAAwB,CAAC;EACpDa,MAAM,GAAGA,MAAM,CAACP,IAAI,CAACd,GAAG,EAAEE,KAAK,CAAC,GAAGM,MAAM,CAACW,GAAG,CAACnB,GAAG,EAAEE,KAAK,CAAC;EACzD,OAAOA,KAAK;AACd,CAAC;AACD,IAAIoB,YAAY;AAChB,IAAIC,EAAE,GAAG,IAAIC,IAAI,CAACC,QAAQ,CAAC,CAAC,EAAE;EAAEC,OAAO,EAAE;AAAE,CAAC,CAAC,CAACC,OAAO;AACrD,SAASC,OAAOA,CAACC,CAAC,EAAEC,CAAC,EAAEC,IAAI,EAAE;EAC3BF,CAAC,GAAGA,CAAC,CAACG,KAAK,CAAC,GAAG,CAAC;EAChBF,CAAC,GAAGA,CAAC,CAACE,KAAK,CAAC,GAAG,CAAC;EAChB,OAAOT,EAAE,CAACM,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAIP,EAAE,CAACM,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAKA,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,EAAEH,IAAI,GAAG,MAAM,CAACI,IAAI,CAACN,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAACI,KAAK,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAEH,IAAI,IAAI,MAAM,CAACI,IAAI,CAACL,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGP,EAAE,CAACM,CAAC,CAAC,CAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;AACvL;AACA,MAAMK,QAAQ,GAAG,MAAM;AACvB,MAAMC,UAAU,GAAG,QAAQ;AAC3B,MAAMC,SAAS,GAAG,OAAO;AACzB,MAAMC,UAAU,GAAG,QAAQ;AAC3B,MAAMC,YAAY,GAAG,MAAM;AAC3B,MAAMC,WAAW,GAAG,SAAS;AAC7B,MAAMC,aAAa,GAAG,WAAW;AACjC,MAAMC,iBAAiB,GAAG,kDAAkD;AAC5E,MAAMC,cAAc,GAAG,wDAAwD;AAC/E,MAAMC,qBAAqB,GAAG,0BAA0B;AACxD,MAAMC,gBAAgB,GAAG,gCAAgC;AACzD,MAAMC,sBAAsB,GAAG,8BAA8B;AAC7D,MAAMC,kBAAkB,GAAG,0BAA0B;AACrD,MAAMC,wBAAwB,GAAG,sCAAsC;AACvE,MAAMC,eAAe,GAAG,2CAA2C;AACnE,MAAMC,gBAAgB,GAAG,uCAAuC;AAChE,MAAMC,uBAAuB,GAAG,wCAAwC;AACxE,MAAMC,uBAAuB,GAAG,sDAAsD;AACtF,MAAMC,mBAAmB,GAAG,8DAA8D;AAC1F,MAAMC,kBAAkB,GAAG,qCAAqC;AAChE,MAAMC,yBAAyB,GAAG,sBAAsB;AACxD,SAASC,YAAYA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,eAAe,EAAE;EAC1D,IAAID,SAAS,CAACE,UAAU,CAAC,SAAS,CAAC,IAAIF,SAAS,CAACE,UAAU,CAAC,UAAU,CAAC,EAAE;IACvE,OAAOD,eAAe,GAAGF,QAAQ,GAAGC,SAAS;EAC/C;EACA,OAAOD,QAAQ,GAAGC,SAAS;AAC7B;AACA,eAAeG,OAAOA,CAACC,KAAK,EAAEC,KAAK,EAAEC,OAAO,EAAE;EAC5C,IAAI;IACF,MAAMC,CAAC,GAAG,MAAMC,KAAK,CAAC,qCAAqCJ,KAAK,MAAM,EAAE;MACtEK,OAAO,EAAE;QACPC,aAAa,EAAE,UAAUL,KAAK,EAAE;QAChC,IAAGC,OAAO,GAAG;UAAEK,MAAM,EAAEL;QAAQ,CAAC,GAAG,CAAC,CAAC;MACvC;IACF,CAAC,CAAC;IACF,MAAMM,GAAG,GAAG,CAAC,MAAML,CAAC,CAACM,IAAI,CAAC,CAAC,EAAER,KAAK;IAClC,OAAOO,GAAG,IAAI,KAAK;EACrB,CAAC,CAAC,OAAOE,CAAC,EAAE;IACV,OAAO,KAAK;EACd;AACF;AACA,SAASC,gBAAgBA,CAACC,GAAG,EAAE;EAC7B,IAAIC,IAAI,GAAG,CAAC,CAAC;EACbD,GAAG,CAACE,OAAO,CAAC,CAAC;IAAEC,QAAQ;IAAEC;EAAG,CAAC,KAAK;IAChC,IAAID,QAAQ,EACVF,IAAI,CAACE,QAAQ,CAAC,GAAGC,EAAE;EACvB,CAAC,CAAC;EACF,OAAOH,IAAI;AACb;AACA,eAAeI,cAAcA,CAACC,QAAQ,EAAE;EACtC,IAAIC,EAAE;EACN,MAAMd,OAAO,GAAG,IAAI,CAACe,OAAO,CAACC,QAAQ,GAAG;IAAEf,aAAa,EAAE,UAAU,IAAI,CAACc,OAAO,CAACC,QAAQ;EAAG,CAAC,GAAG,CAAC,CAAC;EACjGhB,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;EAC5C,IAAI,OAAOiB,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACC,aAAa,IAAIC,QAAQ,CAACC,MAAM,KAAK,uBAAuB,IAAI,CAACH,MAAM,CAACC,aAAa,CAACG,QAAQ,EAAE;IAC1I,MAAMC,IAAI,GAAGL,MAAM,CAACC,aAAa,CAACK,IAAI;IACtC,MAAMC,MAAM,GAAGP,MAAM,CAACC,aAAa;IACnC,IAAIO,WAAW,GAAGpC,YAAY,CAACwB,QAAQ,EAAEW,MAAM,CAACD,IAAI,EAAE,KAAK,CAAC;IAC5DC,MAAM,CAACD,IAAI,GAAGE,WAAW;IACzB,OAAO;MAAE,GAAGD,MAAM;MAAEF;IAAK,CAAC;EAC5B,CAAC,MAAM,IAAIT,QAAQ,EAAE;IACnB,MAAMa,UAAU,GAAGC,SAAS,CAACd,QAAQ,EAAE1C,UAAU,CAAC;IAClD,MAAMyD,QAAQ,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC2B,UAAU,EAAE;MAC5C1B,OAAO;MACP6B,WAAW,EAAE;IACf,CAAC,CAAC;IACF,IAAI,CAACD,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAACf,OAAO,CAACgB,IAAI,EAAE;MAC/E,MAAM,IAAIC,KAAK,CAAC/C,uBAAuB,CAAC;IAC1C,CAAC,MAAM,IAAI,CAAC2C,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,MAAM,MAAM,GAAG,IAAI,IAAI,CAACf,OAAO,CAACgB,IAAI,EAAE;MACrF,MAAM,IAAIC,KAAK,CAAChD,uBAAuB,CAAC;IAC1C;IACA,IAAI,CAAC4C,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,MAAM,MAAM,GAAG,EAAE;MACzD,IAAIN,MAAM,GAAG,MAAMI,QAAQ,CAACxB,IAAI,CAAC,CAAC;MAClCoB,MAAM,CAACF,IAAI,GAAGE,MAAM,CAACF,IAAI,IAAI,EAAE;MAC/BE,MAAM,CAACD,IAAI,GAAGV,QAAQ;MACtB,CAACC,EAAE,GAAGU,MAAM,CAACS,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGnB,EAAE,CAACL,OAAO,CAAC,CAACyB,GAAG,EAAEC,CAAC,KAAK;QACnE,IAAID,GAAG,CAACvB,EAAE,KAAK,KAAK,CAAC,EAAE;UACrBuB,GAAG,CAACvB,EAAE,GAAGwB,CAAC;QACZ;MACF,CAAC,CAAC;MACF,OAAOX,MAAM;IACf,CAAC,MAAM,IAAI,CAACI,QAAQ,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACE,MAAM,MAAM,GAAG,EAAE;MAChE,MAAM,IAAIE,KAAK,CAACjD,gBAAgB,CAAC;IACnC;IACA,MAAM,IAAIiD,KAAK,CAACtD,gBAAgB,CAAC;EACnC;EACA,MAAM,IAAIsD,KAAK,CAACtD,gBAAgB,CAAC;AACnC;AACA,eAAe0D,eAAeA,CAAA,EAAG;EAC/B,MAAM;IAAEC,aAAa;IAAEC;EAAK,CAAC,GAAG,MAAMC,gBAAgB,CACpD,IAAI,CAACC,aAAa,EAClB,IAAI,CAACzB,OAAO,CAACC,QACf,CAAC;EACD,IAAI;IACF,IAAI,IAAI,CAACD,OAAO,CAACgB,IAAI,EAAE;MACrB,MAAMU,aAAa,GAAG,MAAMC,iBAAiB,CAC3CL,aAAa,EACbC,IAAI,EACJ,IAAI,CAACvB,OAAO,CAACgB,IAAI,EACjB,IAAI,CAAChC,KAAK,EACV,IAAI,CAACgB,OAAO,CAACC,QACf,CAAC;MACD,IAAIyB,aAAa,EACf,IAAI,CAACE,WAAW,CAACF,aAAa,CAAC;IACnC;EACF,CAAC,CAAC,OAAOpC,CAAC,EAAE;IACV,MAAM2B,KAAK,CAAC3B,CAAC,CAACuC,OAAO,CAAC;EACxB;AACF;AACA,eAAeF,iBAAiBA,CAACL,aAAa,EAAEC,IAAI,EAAEP,IAAI,EAAEc,MAAM,EAAE7B,QAAQ,EAAE;EAC5E,MAAM8B,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;EAC/BD,QAAQ,CAACE,MAAM,CAAC,UAAU,EAAEjB,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC;EAC5De,QAAQ,CAACE,MAAM,CAAC,UAAU,EAAEjB,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,CAAC;EAC5D,IAAI/B,OAAO,GAAG,CAAC,CAAC;EAChB,IAAIgB,QAAQ,EAAE;IACZhB,OAAO,CAACC,aAAa,GAAG,UAAUe,QAAQ,EAAE;EAC9C;EACA,MAAMiC,GAAG,GAAG,MAAMJ,MAAM,CAAC,GAAGR,aAAa,KAAKC,IAAI,IAAIpE,SAAS,EAAE,EAAE;IACjE8B,OAAO;IACPkD,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEL,QAAQ;IACdjB,WAAW,EAAE;EACf,CAAC,CAAC;EACF,IAAIoB,GAAG,CAACnB,MAAM,KAAK,GAAG,EAAE;IACtB,OAAOmB,GAAG,CAACjD,OAAO,CAACrD,GAAG,CAAC,YAAY,CAAC;EACtC,CAAC,MAAM,IAAIsG,GAAG,CAACnB,MAAM,KAAK,GAAG,EAAE;IAC7B,MAAM,IAAIE,KAAK,CAAChD,uBAAuB,CAAC;EAC1C,CAAC,MAAM;IACL,MAAM,IAAIgD,KAAK,CAACnD,wBAAwB,CAAC;EAC3C;AACF;AACA,SAASuE,kBAAkBA,CAACvC,QAAQ,EAAE;EACpC,IAAIA,QAAQ,CAACpB,UAAU,CAAC,MAAM,CAAC,EAAE;IAC/B,MAAM;MAAE4D,QAAQ;MAAEf,IAAI;MAAEgB;IAAS,CAAC,GAAG,IAAIC,GAAG,CAAC1C,QAAQ,CAAC;IACtD,IAAIyB,IAAI,CAACkB,QAAQ,CAAC,UAAU,CAAC,EAAE;MAC7B,OAAO;QACLC,WAAW,EAAE,KAAK;QAClBnB,IAAI;QACJD,aAAa,EAAEgB;MACjB,CAAC;IACH;IACA,OAAO;MACLI,WAAW,EAAEJ,QAAQ,KAAK,QAAQ,GAAG,KAAK,GAAG,IAAI;MACjDhB,aAAa,EAAEgB,QAAQ;MACvBf,IAAI,EAAEA,IAAI,IAAIgB,QAAQ,KAAK,GAAG,GAAGA,QAAQ,GAAG,EAAE;IAChD,CAAC;EACH,CAAC,MAAM,IAAIzC,QAAQ,CAACpB,UAAU,CAAC,OAAO,CAAC,EAAE;IACvC,OAAO;MACLgE,WAAW,EAAE,IAAI;MACjBpB,aAAa,EAAE,OAAO;MACtBC,IAAI,EAAE;MACN;IACF,CAAC;EACH;EACA,OAAO;IACLmB,WAAW,EAAE,KAAK;IAClBpB,aAAa,EAAE,QAAQ;IACvBC,IAAI,EAAEzB;EACR,CAAC;AACH;AACA,MAAM6C,qBAAqB,GAAIjB,aAAa,IAAK;EAC/C,IAAI5C,OAAO,GAAG,EAAE;EAChB,MAAM8D,KAAK,GAAGlB,aAAa,CAAC7E,KAAK,CAAC,2BAA2B,CAAC;EAC9D+F,KAAK,CAAClD,OAAO,CAAEmD,MAAM,IAAK;IACxB,MAAM,CAACC,WAAW,EAAEC,YAAY,CAAC,GAAGF,MAAM,CAAChG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC;IACnE,IAAIiG,WAAW,IAAIC,YAAY,EAAE;MAC/BjE,OAAO,CAACkE,IAAI,CAAC,GAAGF,WAAW,CAACG,IAAI,CAAC,CAAC,IAAIF,YAAY,CAACE,IAAI,CAAC,CAAC,EAAE,CAAC;IAC9D;EACF,CAAC,CAAC;EACF,OAAOnE,OAAO;AAChB,CAAC;AACD,MAAMoE,aAAa,GAAG,wCAAwC;AAC9D,MAAMC,eAAe,GAAG,qBAAqB;AAC7C,eAAe3B,gBAAgBA,CAACC,aAAa,EAAExB,QAAQ,EAAE;EACvD,MAAMhB,OAAO,GAAG,CAAC,CAAC;EAClB,IAAIgB,QAAQ,EAAE;IACZhB,OAAO,CAACC,aAAa,GAAG,UAAUe,QAAQ,EAAE;EAC9C;EACA,MAAMmD,cAAc,GAAG3B,aAAa,CAACwB,IAAI,CAAC,CAAC,CAACI,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;EAC9D,IAAIH,aAAa,CAAClG,IAAI,CAACoG,cAAc,CAAC,EAAE;IACtC,IAAI;MACF,MAAMlB,GAAG,GAAG,MAAMlD,KAAK,CACrB,qCAAqCoE,cAAc,IAAInG,QAAQ,EAAE,EACjE;QAAEgC;MAAQ,CACZ,CAAC;MACD,MAAMqE,KAAK,GAAG,CAAC,MAAMpB,GAAG,CAAC7C,IAAI,CAAC,CAAC,EAAEkC,IAAI;MACrC,OAAO;QACLgC,QAAQ,EAAE9B,aAAa;QACvB,GAAGY,kBAAkB,CAACiB,KAAK;MAC7B,CAAC;IACH,CAAC,CAAC,OAAOhE,CAAC,EAAE;MACV,MAAM,IAAI2B,KAAK,CAACnD,wBAAwB,CAAC;IAC3C;EACF;EACA,IAAIqF,eAAe,CAACnG,IAAI,CAACoG,cAAc,CAAC,EAAE;IACxC,MAAM;MAAEV,WAAW;MAAEpB,aAAa;MAAEC;IAAK,CAAC,GAAGc,kBAAkB,CAACe,cAAc,CAAC;IAC/E,OAAO;MACLG,QAAQ,EAAEhC,IAAI,CAAC8B,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC;MACvCX,WAAW;MACXpB,aAAa;MACbC;IACF,CAAC;EACH;EACA,OAAO;IACLgC,QAAQ,EAAE,KAAK;IACf,GAAGlB,kBAAkB,CAACe,cAAc;EACtC,CAAC;AACH;AACA,MAAMxC,SAAS,GAAGA,CAAC,GAAG4C,IAAI,KAAK;EAC7B,IAAI;IACF,OAAOA,IAAI,CAACC,MAAM,CAAC,CAAClF,QAAQ,EAAEmF,IAAI,KAAK;MACrCnF,QAAQ,GAAGA,QAAQ,CAAC8E,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;MACvCK,IAAI,GAAGA,IAAI,CAACL,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;MAC/B,OAAO,IAAIb,GAAG,CAACkB,IAAI,EAAEnF,QAAQ,GAAG,GAAG,CAAC,CAACoF,QAAQ,CAAC,CAAC;IACjD,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOrE,CAAC,EAAE;IACV,MAAM,IAAI2B,KAAK,CAAClD,eAAe,CAAC;EAClC;AACF,CAAC;AACD,SAAS6F,kBAAkBA,CAACC,QAAQ,EAAEpD,MAAM,EAAEqD,OAAO,EAAE;EACrD,MAAMC,gBAAgB,GAAG;IACvBC,eAAe,EAAE,CAAC,CAAC;IACnBC,iBAAiB,EAAE,CAAC;EACtB,CAAC;EACDvJ,MAAM,CAACwJ,IAAI,CAACL,QAAQ,CAAC,CAACnE,OAAO,CAAEyE,QAAQ,IAAK;IAC1C,IAAIA,QAAQ,KAAK,iBAAiB,IAAIA,QAAQ,KAAK,mBAAmB,EAAE;MACtEJ,gBAAgB,CAACI,QAAQ,CAAC,GAAG,CAAC,CAAC;MAC/BzJ,MAAM,CAAC0J,OAAO,CAACP,QAAQ,CAACM,QAAQ,CAAC,CAAC,CAACzE,OAAO,CACxC,CAAC,CAACI,QAAQ,EAAE;QAAEuE,UAAU;QAAEC;MAAQ,CAAC,CAAC,KAAK;QACvC,IAAIvE,EAAE,EAAEwE,EAAE,EAAEC,EAAE,EAAEC,EAAE;QAClB,MAAMC,eAAe,GAAG,CAAC,CAAC3E,EAAE,GAAGU,MAAM,CAACS,YAAY,CAACyD,IAAI,CACpDxD,GAAG,IAAKA,GAAG,CAACxB,QAAQ,KAAKG,QAAQ,IAAIqB,GAAG,CAACxB,QAAQ,KAAKG,QAAQ,CAACuD,OAAO,CAAC,GAAG,EAAE,EAAE,CACjF,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGtD,EAAE,CAACH,EAAE,KAAKkE,OAAO,CAAChE,QAAQ,CAACuD,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;QACxE,MAAMuB,eAAe,GAAGF,eAAe,KAAK,CAAC,CAAC,GAAG,CAACH,EAAE,GAAG9D,MAAM,CAACS,YAAY,CAACyD,IAAI,CAAExD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAI8E,eAAe,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGH,EAAE,CAACM,KAAK,GAAG;UAAEC,SAAS,EAAE,KAAK;UAAEC,MAAM,EAAE;QAAM,CAAC;QACtL,IAAIL,eAAe,KAAK,CAAC,CAAC,IAAI,CAAC,CAACD,EAAE,GAAG,CAACD,EAAE,GAAG/D,MAAM,CAACS,YAAY,CAACyD,IAAI,CAAExD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAI8E,eAAe,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGF,EAAE,CAACQ,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGP,EAAE,CAACQ,MAAM,MAAMZ,UAAU,CAACY,MAAM,EAAE;UAC1L,MAAMC,UAAU,GAAGzE,MAAM,CAACS,YAAY,CAACyD,IAAI,CAAExD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAI8E,eAAe,CAAC,CAACM,MAAM,CAACG,GAAG,CACvFC,KAAK,IAAK;YACT,IAAIC,GAAG;YACP,OAAO,CAACA,GAAG,GAAG5E,MAAM,CAACyE,UAAU,CAACP,IAAI,CAAEW,CAAC,IAAKA,CAAC,CAAC1F,EAAE,KAAKwF,KAAK,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGC,GAAG,CAACE,IAAI;UAC1F,CACF,CAAC;UACD,IAAI;YACFL,UAAU,CAACxF,OAAO,CAAC,CAAC8F,IAAI,EAAEC,GAAG,KAAK;cAChC,IAAID,IAAI,KAAK,OAAO,EAAE;gBACpB,MAAME,SAAS,GAAG;kBAChBC,SAAS,EAAE,OAAO;kBAClBC,OAAO,EAAE,IAAI;kBACbC,iBAAiB,EAAE,IAAI;kBACvBC,qBAAqB,EAAE,IAAI;kBAC3BC,cAAc,EAAE,IAAI;kBACpBC,MAAM,EAAE;gBACV,CAAC;gBACD3B,UAAU,CAAC4B,MAAM,CAACR,GAAG,EAAE,CAAC,EAAEC,SAAS,CAAC;cACtC;YACF,CAAC,CAAC;UACJ,CAAC,CAAC,OAAOpG,CAAC,EAAE;YACV4G,OAAO,CAACC,KAAK,CAAC7G,CAAC,CAAC;UAClB;QACF;QACA,MAAM8G,cAAc,GAAGA,CAACC,IAAI,EAAEV,SAAS,EAAEW,UAAU,EAAEC,cAAc,MAAM;UACvE,GAAGF,IAAI;UACPG,WAAW,EAAEC,eAAe,CAACJ,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACd,IAAI,EAAEe,UAAU,CAAC;UAC3Ef,IAAI,EAAEmB,QAAQ,CAACL,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACd,IAAI,EAAEI,SAAS,EAAEW,UAAU,EAAEC,cAAc,CAAC,IAAI;QAC9F,CAAC,CAAC;QACFxC,gBAAgB,CAACI,QAAQ,CAAC,CAACrE,QAAQ,CAAC,GAAG;UACrCuE,UAAU,EAAEA,UAAU,CAACc,GAAG,CACvBwB,CAAC,IAAKP,cAAc,CAACO,CAAC,EAAEA,CAAC,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,CAAC,CAAChB,SAAS,EAAEgB,CAAC,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACL,UAAU,EAAE,WAAW,CAC3G,CAAC;UACDhC,OAAO,EAAEA,OAAO,CAACa,GAAG,CACjBpG,CAAC,IAAKqH,cAAc,CAACrH,CAAC,EAAEA,CAAC,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,CAAC,CAAC4G,SAAS,EAAE5G,CAAC,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,CAAC,CAACuH,UAAU,EAAE,QAAQ,CACxG,CAAC;UACDf,IAAI,EAAEX;QACR,CAAC;MACH,CACF,CAAC;IACH;EACF,CAAC,CAAC;EACF,OAAOb,gBAAgB;AACzB;AACA,SAAS2C,QAAQA,CAACnB,IAAI,EAAEI,SAAS,EAAEW,UAAU,EAAEC,cAAc,EAAE;EAC7D,QAAQhB,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACA,IAAI;IACvC,KAAK,QAAQ;MACX,OAAO,QAAQ;IACjB,KAAK,SAAS;MACZ,OAAO,SAAS;IAClB,KAAK,QAAQ;MACX,OAAO,QAAQ;EACnB;EACA,IAAIe,UAAU,KAAK,kBAAkB,IAAIA,UAAU,KAAK,oBAAoB,EAAE;IAC5E,OAAO,KAAK;EACd,CAAC,MAAM,IAAIA,UAAU,KAAK,wBAAwB,EAAE;IAClD,OAAO,UAAU;EACnB,CAAC,MAAM,IAAIX,SAAS,KAAK,OAAO,EAAE;IAChC,OAAOY,cAAc,KAAK,WAAW,GAAG,sBAAsB,GAAG,QAAQ;EAC3E,CAAC,MAAM,IAAID,UAAU,KAAK,kBAAkB,EAAE;IAC5C,IAAI,CAACf,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACA,IAAI,MAAM,OAAO,EAAE;MACnD,OAAOgB,cAAc,KAAK,WAAW,GAAG,0BAA0B,GAAG,uFAAuF;IAC9J;IACA,OAAOA,cAAc,KAAK,WAAW,GAAG,sBAAsB,GAAG,qFAAqF;EACxJ,CAAC,MAAM,IAAID,UAAU,KAAK,qBAAqB,EAAE;IAC/C,OAAOC,cAAc,KAAK,WAAW,GAAG,6CAA6C,GAAG,2GAA2G;EACrM;AACF;AACA,SAASE,eAAeA,CAAClB,IAAI,EAAEe,UAAU,EAAE;EACzC,IAAIA,UAAU,KAAK,qBAAqB,EAAE;IACxC,OAAO,+BAA+B;EACxC,CAAC,MAAM,IAAIA,UAAU,KAAK,wBAAwB,EAAE;IAClD,OAAO,kBAAkB;EAC3B,CAAC,MAAM,IAAIA,UAAU,KAAK,kBAAkB,EAAE;IAC5C,OAAO,+BAA+B;EACxC;EACA,OAAOf,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACiB,WAAW;AACjD;AACA,SAASI,cAAcA,CAACP,IAAI,EAAEQ,WAAW,EAAE;EACzC,MAAMC,KAAK,GAAG,IAAI;EAClB,QAAQT,IAAI,CAAC/K,GAAG;IACd,KAAK,WAAW;MACd,OAAO;QAAEiK,IAAI,EAAE;MAAO,CAAC;IACzB,KAAK,WAAW;MACd,OAAO;QAAEA,IAAI,EAAE;MAAO,CAAC;IACzB,KAAK,YAAY;MACf,OAAO;QACLA,IAAI,EAAE,QAAQ;QACdxE,MAAM,EAAE;UACN+F,KAAK;UACLjF,OAAO,EAAEpE,cAAc;UACvBsJ,KAAK,EAAE,OAAO;UACdC,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfC,OAAO,EAAEZ,IAAI,CAACY;QAChB;MACF,CAAC;IACH,KAAK,WAAW;MACd,OAAO;QACL1B,IAAI,EAAE;MACR,CAAC;IACH,KAAK,kBAAkB;MACrB,OAAO;QACLA,IAAI,EAAE,kBAAkB;QACxBxE,MAAM,EAAE;UACN+F,KAAK;UACLjF,OAAO,EAAEwE,IAAI,CAACxE,OAAO;UACrBkF,KAAK,EAAE,OAAO;UACdE,OAAO,EAAE;QACX;MACF,CAAC;IACH,KAAK,YAAY;MACf,OAAO;QACL1B,IAAI,EAAE,QAAQ;QACdxE,MAAM,EAAE;UACN+F,KAAK;UACLC,KAAK,EAAEF,WAAW,IAAI,SAAS;UAC/BG,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfE,IAAI,EAAEb,IAAI,CAACc,UAAU;UACrBC,QAAQ,EAAEf,IAAI,CAACgB,IAAI;UACnBC,GAAG,EAAEjB,IAAI,CAACkB,QAAQ;UAClBN,OAAO,EAAEZ,IAAI,CAACY;QAChB;MACF,CAAC;IACH,KAAK,UAAU;MACb,OAAO;QACL1B,IAAI,EAAE,QAAQ;QACdxE,MAAM,EAAE;UACN+F,KAAK;UACLC,KAAK,EAAE,SAAS;UAChBC,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfQ,aAAa,EAAEnB,IAAI,CAACmB,aAAa;UACjCP,OAAO,EAAEZ,IAAI,CAACY;QAChB;MACF,CAAC;IACH,KAAK,KAAK;MACR,OAAO;QAAE1B,IAAI,EAAE,KAAK;QAAEc;MAAK,CAAC;IAC9B,KAAK,oBAAoB;MACvB,OAAO;QACLd,IAAI,EAAE,YAAY;QAClBxE,MAAM,EAAE;UACN+F,KAAK;UACLjF,OAAO,EAAE,CAACwE,IAAI,CAACY,OAAO,GAAGZ,IAAI,CAACoB,MAAM,CAACtB,KAAK,GAAG,IAAI;UACjDY,KAAK,EAAEV,IAAI,CAACY,OAAO,GAAG,YAAY,GAAG,OAAO;UAC5CD,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfQ,aAAa,EAAEnB,IAAI,CAACmB,aAAa;UACjCF,GAAG,EAAEjB,IAAI,CAACqB;QACZ,CAAC;QACDrB,IAAI,EAAEA,IAAI,CAACY,OAAO,GAAGZ,IAAI,CAACoB,MAAM,GAAG;MACrC,CAAC;IACH,KAAK,mBAAmB;MACtB,IAAI,OAAO,IAAIpB,IAAI,CAACoB,MAAM,EAAE;QAC1B,OAAO;UACLlC,IAAI,EAAE,QAAQ;UACdxE,MAAM,EAAE;YACN+F,KAAK;YACLjF,OAAO,EAAEwE,IAAI,CAACoB,MAAM,CAACtB,KAAK;YAC1BwB,OAAO,EAAEtB,IAAI,CAACoB,MAAM,CAACE,OAAO;YAC5BC,QAAQ,EAAEvB,IAAI,CAACoB,MAAM,CAACG,QAAQ;YAC9Bb,KAAK,EAAE,OAAO;YACdC,IAAI,EAAEX,IAAI,CAACW,IAAI;YACfC,OAAO,EAAEZ,IAAI,CAACY;UAChB;QACF,CAAC;MACH;MACA,OAAO;QACL1B,IAAI,EAAE,UAAU;QAChBxE,MAAM,EAAE;UACN+F,KAAK;UACLjF,OAAO,EAAE,CAACwE,IAAI,CAACY,OAAO,GAAGZ,IAAI,CAACoB,MAAM,CAACtB,KAAK,GAAG,KAAK,CAAC;UACnDY,KAAK,EAAEV,IAAI,CAACY,OAAO,GAAG,UAAU,GAAG,OAAO;UAC1CD,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfQ,aAAa,EAAEnB,IAAI,CAACmB,aAAa;UACjCK,iBAAiB,EAAExB,IAAI,CAACY,OAAO,GAAGZ,IAAI,CAACoB,MAAM,CAACI,iBAAiB,GAAG,KAAK;QACzE,CAAC;QACDxB,IAAI,EAAEA,IAAI,CAACY,OAAO,GAAGZ,IAAI,CAACoB,MAAM,GAAG;MACrC,CAAC;IACH,KAAK,gBAAgB;MACnB,OAAO;QACLlC,IAAI,EAAE,QAAQ;QACdxE,MAAM,EAAE;UACN+F,KAAK;UACLC,KAAK,EAAE,SAAS;UAChBC,IAAI,EAAEX,IAAI,CAACW,IAAI;UACfE,IAAI,EAAEb,IAAI,CAACgB,IAAI;UACfD,QAAQ,EAAE,CAAC;UACXH,OAAO,EAAEZ,IAAI,CAACY,OAAO;UACrBK,GAAG,EAAEjB,IAAI,CAACiB;QACZ;MACF,CAAC;EACL;EACA,OAAO;IAAE/B,IAAI,EAAE,MAAM;IAAExE,MAAM,EAAE;MAAEgG,KAAK,EAAE,OAAO;MAAED;IAAM;EAAE,CAAC;AAC5D;AACA,MAAMgB,kBAAkB,GAAGA,CAACzB,IAAI,GAAG,EAAE,EAAE0B,aAAa,KAAK;EACvD,MAAM1D,UAAU,GAAG0D,aAAa,GAAGA,aAAa,CAAC1D,UAAU,GAAG,EAAE;EAChE,IAAI2D,KAAK,CAACC,OAAO,CAAC5B,IAAI,CAAC,EAAE;IACvB,IAAIA,IAAI,CAACpB,MAAM,GAAGZ,UAAU,CAACY,MAAM,EAAE;MACnCiB,OAAO,CAACgC,IAAI,CAAC,+CAA+C,CAAC;IAC/D;IACA,OAAO7B,IAAI;EACb;EACA,MAAM8B,aAAa,GAAG,EAAE;EACxB,MAAMC,aAAa,GAAG1N,MAAM,CAACwJ,IAAI,CAACmC,IAAI,CAAC;EACvChC,UAAU,CAAC3E,OAAO,CAAC,CAAC2I,KAAK,EAAEC,KAAK,KAAK;IACnC,IAAIjC,IAAI,CAACkC,cAAc,CAACF,KAAK,CAACtC,cAAc,CAAC,EAAE;MAC7CoC,aAAa,CAACG,KAAK,CAAC,GAAGjC,IAAI,CAACgC,KAAK,CAACtC,cAAc,CAAC;IACnD,CAAC,MAAM,IAAIsC,KAAK,CAACvC,qBAAqB,EAAE;MACtCqC,aAAa,CAACG,KAAK,CAAC,GAAGD,KAAK,CAACxC,iBAAiB;IAChD,CAAC,MAAM;MACL,MAAM,IAAI5E,KAAK,CACb,6CAA6CoH,KAAK,CAACtC,cAAc,EACnE,CAAC;IACH;EACF,CAAC,CAAC;EACFqC,aAAa,CAAC1I,OAAO,CAAE5E,GAAG,IAAK;IAC7B,IAAI,CAACuJ,UAAU,CAACmE,IAAI,CAAEH,KAAK,IAAKA,KAAK,CAACtC,cAAc,KAAKjL,GAAG,CAAC,EAAE;MAC7D,MAAM,IAAImG,KAAK,CACb,eAAenG,GAAG,wEACpB,CAAC;IACH;EACF,CAAC,CAAC;EACFqN,aAAa,CAACzI,OAAO,CAAC,CAAC3E,KAAK,EAAE0K,GAAG,KAAK;IACpC,IAAI1K,KAAK,KAAK,KAAK,CAAC,IAAI,CAACsJ,UAAU,CAACoB,GAAG,CAAC,CAACK,qBAAqB,EAAE;MAC9D,MAAM,IAAI7E,KAAK,CACb,6CAA6CoD,UAAU,CAACoB,GAAG,CAAC,CAACM,cAAc,EAC7E,CAAC;IACH;EACF,CAAC,CAAC;EACF,OAAOoC,aAAa;AACtB,CAAC;AACD,eAAeM,QAAQA,CAAA,EAAG;EACxB,IAAI,IAAI,CAAC5E,QAAQ,EACf,OAAO,IAAI,CAACA,QAAQ;EACtB,MAAM;IAAE5D;EAAS,CAAC,GAAG,IAAI,CAACD,OAAO;EACjC,MAAM;IAAES;EAAO,CAAC,GAAG,IAAI;EACvB,MAAMxB,OAAO,GAAG;IAAE,cAAc,EAAE;EAAmB,CAAC;EACtD,IAAIgB,QAAQ,EAAE;IACZhB,OAAO,CAACC,aAAa,GAAG,UAAUe,QAAQ,EAAE;EAC9C;EACA,IAAI,CAACQ,MAAM,EAAE;IACX;EACF;EACA,IAAI;IACF,IAAII,QAAQ;IACZ,IAAIgD,QAAQ;IACZ,IAAI,OAAO3D,MAAM,KAAK,WAAW,IAAIA,MAAM,CAACwI,eAAe,EAAE;MAC3D7E,QAAQ,GAAG3D,MAAM,CAACwI,eAAe;IACnC,CAAC,MAAM;MACL,IAAIjM,OAAO,CAAC,CAACgE,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACkI,OAAO,KAAK,OAAO,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE;QAC9E9H,QAAQ,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAACxB,iBAAiB,EAAE;UAC7C2E,MAAM,EAAE,MAAM;UACdC,IAAI,EAAEwG,IAAI,CAACC,SAAS,CAAC;YACnBC,SAAS,EAAE,KAAK;YAChBrI,MAAM,EAAEmI,IAAI,CAACC,SAAS,CAACpI,MAAM;UAC/B,CAAC,CAAC;UACFxB,OAAO;UACP6B,WAAW,EAAE;QACf,CAAC,CAAC;MACJ,CAAC,MAAM;QACL,MAAMiI,GAAG,GAAGnI,SAAS,CAACH,MAAM,CAACD,IAAI,EAAEnD,YAAY,CAAC;QAChDwD,QAAQ,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC+J,GAAG,EAAE;UAC/B9J,OAAO;UACP6B,WAAW,EAAE;QACf,CAAC,CAAC;MACJ;MACA,IAAI,CAACD,QAAQ,CAACmI,EAAE,EAAE;QAChB,MAAM,IAAI/H,KAAK,CAACvD,qBAAqB,CAAC;MACxC;MACAmG,QAAQ,GAAG,MAAMhD,QAAQ,CAACxB,IAAI,CAAC,CAAC;IAClC;IACA,IAAI,KAAK,IAAIwE,QAAQ,EAAE;MACrBA,QAAQ,GAAGA,QAAQ,CAACoF,GAAG;IACzB;IACA,IAAIpF,QAAQ,CAACG,eAAe,CAAC,UAAU,CAAC,IAAI,CAACH,QAAQ,CAACI,iBAAiB,CAAC,GAAG,CAAC,EAAE;MAC5EJ,QAAQ,CAACI,iBAAiB,CAAC,CAAC,CAAC,GAAGJ,QAAQ,CAACG,eAAe,CAAC,UAAU,CAAC;IACtE;IACA,OAAOJ,kBAAkB,CAACC,QAAQ,EAAEpD,MAAM,EAAE,IAAI,CAACqD,OAAO,CAAC;EAC3D,CAAC,CAAC,OAAOxE,CAAC,EAAE;IACV,0BAA0B,GAAGA,CAAC,CAACuC,OAAO;EACxC;AACF;AACA,eAAeqH,YAAYA,CAACC,QAAQ,EAAEC,KAAK,EAAEC,SAAS,EAAE;EACtD,IAAItJ,EAAE;EACN,MAAMd,OAAO,GAAG,CAAC,CAAC;EAClB,IAAI,CAACc,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAG,IAAI,CAACC,OAAO,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGD,EAAE,CAACE,QAAQ,EAAE;IAC9EhB,OAAO,CAACC,aAAa,GAAG,UAAU,IAAI,CAACc,OAAO,CAACC,QAAQ,EAAE;EAC3D;EACA,MAAMqJ,SAAS,GAAG,GAAG;EACrB,MAAMC,eAAe,GAAG,EAAE;EAC1B,IAAI1I,QAAQ;EACZ,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgI,KAAK,CAACnE,MAAM,EAAE7D,CAAC,IAAIkI,SAAS,EAAE;IAChD,MAAME,KAAK,GAAGJ,KAAK,CAACtM,KAAK,CAACsE,CAAC,EAAEA,CAAC,GAAGkI,SAAS,CAAC;IAC3C,MAAMvH,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BwH,KAAK,CAAC9J,OAAO,CAAE+J,IAAI,IAAK;MACtB1H,QAAQ,CAACE,MAAM,CAAC,OAAO,EAAEwH,IAAI,CAAC;IAChC,CAAC,CAAC;IACF,IAAI;MACF,MAAMC,UAAU,GAAGL,SAAS,GAAG,GAAGF,QAAQ,IAAIjM,UAAU,cAAcmM,SAAS,EAAE,GAAG,GAAGF,QAAQ,IAAIjM,UAAU,EAAE;MAC/G2D,QAAQ,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC0K,UAAU,EAAE;QACtCvH,MAAM,EAAE,MAAM;QACdC,IAAI,EAAEL,QAAQ;QACd9C,OAAO;QACP6B,WAAW,EAAE;MACf,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOxB,CAAC,EAAE;MACV,MAAM,IAAI2B,KAAK,CAACvD,qBAAqB,GAAG4B,CAAC,CAACuC,OAAO,CAAC;IACpD;IACA,IAAI,CAAChB,QAAQ,CAACmI,EAAE,EAAE;MAChB,MAAMW,UAAU,GAAG,MAAM9I,QAAQ,CAAC+I,IAAI,CAAC,CAAC;MACxC,OAAO;QAAEzD,KAAK,EAAE,QAAQtF,QAAQ,CAACE,MAAM,KAAK4I,UAAU;MAAG,CAAC;IAC5D;IACA,MAAMlC,MAAM,GAAG,MAAM5G,QAAQ,CAACxB,IAAI,CAAC,CAAC;IACpC,IAAIoI,MAAM,EAAE;MACV8B,eAAe,CAACvG,IAAI,CAAC,GAAGyE,MAAM,CAAC;IACjC;EACF;EACA,OAAO;IAAE2B,KAAK,EAAEG;EAAgB,CAAC;AACnC;AACA,eAAeM,MAAMA,CAACC,SAAS,EAAEX,QAAQ,EAAEE,SAAS,EAAEU,aAAa,EAAE;EACnE,IAAIX,KAAK,GAAG,CAACpB,KAAK,CAACC,OAAO,CAAC6B,SAAS,CAAC,GAAGA,SAAS,GAAG,CAACA,SAAS,CAAC,EAAE3E,GAAG,CACjE6E,UAAU,IAAKA,UAAU,CAACC,IAC7B,CAAC;EACD,MAAMC,eAAe,GAAGd,KAAK,CAACe,MAAM,CACjCC,CAAC,IAAKA,CAAC,CAAClD,IAAI,IAAI6C,aAAa,IAAIM,QAAQ,CAC5C,CAAC;EACD,IAAIH,eAAe,CAACjF,MAAM,EAAE;IAC1B,MAAM,IAAIhE,KAAK,CACb,iDAAiD8I,aAAa,WAAWG,eAAe,CAAC/E,GAAG,CAAEiF,CAAC,IAAKA,CAAC,CAACE,IAAI,CAAC,CAACvN,IAAI,CAAC,IAAI,CAAC,EACxH,CAAC;EACH;EACA,OAAO,MAAMwN,OAAO,CAACC,GAAG,CACtB,MAAM,IAAI,CAACtB,YAAY,CAACC,QAAQ,EAAEC,KAAK,EAAEC,SAAS,CAAC,CAACoB,IAAI,CACtD,MAAO5J,QAAQ,IAAK;IAClB,IAAIA,QAAQ,CAACsF,KAAK,EAAE;MAClB,MAAM,IAAIlF,KAAK,CAACJ,QAAQ,CAACsF,KAAK,CAAC;IACjC,CAAC,MAAM;MACL,IAAItF,QAAQ,CAACuI,KAAK,EAAE;QAClB,OAAOvI,QAAQ,CAACuI,KAAK,CAACjE,GAAG,CAAC,CAACiF,CAAC,EAAEhJ,CAAC,KAAK;UAClC,MAAMqI,IAAI,GAAG,IAAIiB,QAAQ,CAAC;YACxB,GAAGZ,SAAS,CAAC1I,CAAC,CAAC;YACfb,IAAI,EAAE6J,CAAC;YACPrB,GAAG,EAAEI,QAAQ,GAAG,QAAQ,GAAGiB;UAC7B,CAAC,CAAC;UACF,OAAOX,IAAI;QACb,CAAC,CAAC;MACJ;MACA,OAAO,EAAE;IACX;EACF,CACF,CACF,CAAC;AACH;AACA,eAAekB,aAAaA,CAACvB,KAAK,EAAEwB,SAAS,EAAE;EAC7C,OAAOxB,KAAK,CAACjE,GAAG,CACbiF,CAAC,IAAK,IAAIM,QAAQ,CAAC;IAClBnK,IAAI,EAAE6J,CAAC,CAACE,IAAI;IACZO,SAAS,EAAET,CAAC,CAACE,IAAI;IACjBL,IAAI,EAAEG,CAAC;IACPlD,IAAI,EAAEkD,CAAC,CAAClD,IAAI;IACZ4D,SAAS,EAAEV,CAAC,CAAC7E,IAAI;IACjBqF;EACF,CAAC,CACH,CAAC;AACH;AACA,MAAMF,QAAQ,CAAC;EACbK,WAAWA,CAAC;IACVxK,IAAI;IACJwI,GAAG;IACH8B,SAAS;IACT3D,IAAI;IACJ+C,IAAI;IACJW,SAAS;IACTE,SAAS;IACTE;EACF,CAAC,EAAE;IACD7P,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;IAC3BA,aAAa,CAAC,IAAI,EAAE,KAAK,CAAC;IAC1BA,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;IAChCA,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;IAC3BA,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;IAC3BA,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;IAChCA,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;IAChCA,aAAa,CAAC,IAAI,EAAE,UAAU,CAAC;IAC/BA,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE;MAAE8P,KAAK,EAAE;IAAkB,CAAC,CAAC;IACzD,IAAI,CAAC1K,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACwI,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC8B,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAAC3D,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC+C,IAAI,GAAGlB,GAAG,GAAG,KAAK,CAAC,GAAGkB,IAAI;IAC/B,IAAI,CAACW,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACE,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACE,QAAQ,GAAGA,QAAQ;EAC1B;AACF;AACA,MAAME,OAAO,CAAC;EACZH,WAAWA,CAACI,OAAO,EAAEC,IAAI,EAAE;IACzBjQ,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;IAC3BA,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC;IAC9BA,aAAa,CAAC,IAAI,EAAE,MAAM,CAAC;IAC3BA,aAAa,CAAC,IAAI,EAAE,UAAU,CAAC;IAC/B,IAAI,CAACoK,IAAI,GAAG,SAAS;IACrB,IAAI,CAAC4F,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,IAAI,GAAGA,IAAI;EAClB;AACF;AACA,MAAMC,OAAO,GAAG,OAAOC,OAAO,KAAK,WAAW,IAAIA,OAAO,CAACC,QAAQ,IAAID,OAAO,CAACC,QAAQ,CAACC,IAAI;AAC3F,SAASC,aAAaA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,KAAK,EAAE;EAC9C,OAAOA,KAAK,CAAC3G,MAAM,GAAG,CAAC,EAAE;IACvB,MAAM4G,IAAI,GAAGD,KAAK,CAACE,KAAK,CAAC,CAAC;IAC1B,IAAI,OAAOD,IAAI,KAAK,QAAQ,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MACxDH,MAAM,GAAGA,MAAM,CAACG,IAAI,CAAC;IACvB,CAAC,MAAM;MACL,MAAM,IAAI5K,KAAK,CAAC,kBAAkB,CAAC;IACrC;EACF;EACA,MAAMnG,GAAG,GAAG8Q,KAAK,CAACE,KAAK,CAAC,CAAC;EACzB,IAAI,OAAOhR,GAAG,KAAK,QAAQ,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACtD4Q,MAAM,CAAC5Q,GAAG,CAAC,GAAG6Q,QAAQ;EACxB,CAAC,MAAM;IACL,MAAM,IAAI1K,KAAK,CAAC,kBAAkB,CAAC;EACrC;AACF;AACA,eAAe8K,oBAAoBA,CAAC1F,IAAI,EAAEd,IAAI,GAAG,KAAK,CAAC,EAAEhF,IAAI,GAAG,EAAE,EAAEC,IAAI,GAAG,KAAK,EAAEuH,aAAa,GAAG,KAAK,CAAC,EAAE;EACxG,IAAIC,KAAK,CAACC,OAAO,CAAC5B,IAAI,CAAC,EAAE;IACvB,IAAI2F,SAAS,GAAG,EAAE;IAClB,MAAMzB,OAAO,CAACC,GAAG,CACfnE,IAAI,CAAClB,GAAG,CAAC,OAAO8G,CAAC,EAAE3D,KAAK,KAAK;MAC3B,IAAIvI,EAAE;MACN,IAAImM,QAAQ,GAAG3L,IAAI,CAACzD,KAAK,CAAC,CAAC;MAC3BoP,QAAQ,CAAClJ,IAAI,CAACmJ,MAAM,CAAC7D,KAAK,CAAC,CAAC;MAC5B,MAAM8D,UAAU,GAAG,MAAML,oBAAoB,CAC3C1F,IAAI,CAACiC,KAAK,CAAC,EACX9H,IAAI,GAAG,CAAC,CAACT,EAAE,GAAGgI,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAAC1D,UAAU,CAACiE,KAAK,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGvI,EAAE,CAAC4F,SAAS,KAAK,KAAK,CAAC,GAAGJ,IAAI,EACjI2G,QAAQ,EACR,KAAK,EACLnE,aACF,CAAC;MACDiE,SAAS,GAAGA,SAAS,CAACK,MAAM,CAACD,UAAU,CAAC;IAC1C,CAAC,CACH,CAAC;IACD,OAAOJ,SAAS;EAClB,CAAC,MAAM,IAAIM,UAAU,CAACC,MAAM,IAAIlG,IAAI,YAAYiG,UAAU,CAACC,MAAM,IAAIlG,IAAI,YAAYmG,IAAI,EAAE;IACzF,OAAO,CACL;MACEjM,IAAI;MACJ0J,IAAI,EAAE,IAAIuC,IAAI,CAAC,CAACnG,IAAI,CAAC,CAAC;MACtBd;IACF,CAAC,CACF;EACH,CAAC,MAAM,IAAI,OAAOc,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,IAAI,EAAE;IACpD,IAAI2F,SAAS,GAAG,EAAE;IAClB,KAAK,MAAMlR,GAAG,IAAIJ,MAAM,CAACwJ,IAAI,CAACmC,IAAI,CAAC,EAAE;MACnC,MAAM6F,QAAQ,GAAG,CAAC,GAAG3L,IAAI,EAAEzF,GAAG,CAAC;MAC/B,MAAMC,KAAK,GAAGsL,IAAI,CAACvL,GAAG,CAAC;MACvBkR,SAAS,GAAGA,SAAS,CAACK,MAAM,CAC1B,MAAMN,oBAAoB,CACxBhR,KAAK,EACL,KAAK,CAAC,EACNmR,QAAQ,EACR,KAAK,EACLnE,aACF,CACF,CAAC;IACH;IACA,OAAOiE,SAAS;EAClB;EACA,OAAO,EAAE;AACX;AACA,SAASS,UAAUA,CAAC7M,EAAE,EAAEa,MAAM,EAAE;EAC9B,IAAIV,EAAE,EAAEwE,EAAE;EACV,IAAImI,QAAQ,GAAG,CAACnI,EAAE,GAAG,CAACxE,EAAE,GAAGU,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACS,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGnB,EAAE,CAAC4E,IAAI,CAAExD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAIA,EAAE,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG2E,EAAE,CAACuC,KAAK;EACxJ,IAAI4F,QAAQ,IAAI,IAAI,EAAE;IACpB,OAAO,CAACA,QAAQ;EAClB;EACA,OAAO,CAACjM,MAAM,CAACkM,YAAY;AAC7B;AACA,SAASC,YAAYA,CAAC/K,OAAO,EAAExB,MAAM,EAAE;EACrC,OAAO,IAAIkK,OAAO,CAAC,CAACrI,GAAG,EAAE2K,IAAI,KAAK;IAChC,MAAMC,OAAO,GAAG,IAAIC,cAAc,CAAC,CAAC;IACpCD,OAAO,CAACE,KAAK,CAACC,SAAS,GAAG,CAAC;MAAE5G;IAAK,CAAC,KAAK;MACtCyG,OAAO,CAACE,KAAK,CAACE,KAAK,CAAC,CAAC;MACrBhL,GAAG,CAACmE,IAAI,CAAC;IACX,CAAC;IACDnG,MAAM,CAACiN,MAAM,CAACC,WAAW,CAACvL,OAAO,EAAExB,MAAM,EAAE,CAACyM,OAAO,CAACO,KAAK,CAAC,CAAC;EAC7D,CAAC,CAAC;AACJ;AACA,SAASC,WAAWA,CAACC,WAAW,EAAE;EAChC,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;IACnC,IAAIA,WAAW,CAAC7O,UAAU,CAAC,SAAS,CAAC,IAAI6O,WAAW,CAAC7O,UAAU,CAAC,UAAU,CAAC,EAAE;MAC3E,OAAO;QACL6B,IAAI,EAAEgN,WAAW;QACjBxE,GAAG,EAAEwE,WAAW;QAChB1C,SAAS,EAAE0C,WAAW,CAAC1Q,KAAK,CAAC,GAAG,CAAC,CAAC2Q,GAAG,CAAC,CAAC,IAAI,SAAS;QACpDpC,IAAI,EAAE;UAAEH,KAAK,EAAE;QAAkB;MACnC,CAAC;IACH;IACA,IAAII,OAAO,EAAE;MACX,OAAO,IAAIH,OAAO,CAAC,aAAa,EAAE;QAChC3K,IAAI,EAAEgN,WAAW;QACjBjD,IAAI,EAAEiD,WAAW;QACjBE,SAAS,EAAEF;MACb,CAAC,CAAC;IACJ;EACF,CAAC,MAAM,IAAI,OAAOG,IAAI,KAAK,WAAW,IAAIH,WAAW,YAAYG,IAAI,EAAE;IACrE,OAAO,IAAIlB,IAAI,CAAC,CAACe,WAAW,CAAC,CAAC;EAChC,CAAC,MAAM,IAAIA,WAAW,YAAYhB,MAAM,EAAE;IACxC,OAAO,IAAIC,IAAI,CAAC,CAACe,WAAW,CAAC,CAAC;EAChC,CAAC,MAAM,IAAIA,WAAW,YAAYf,IAAI,EAAE;IACtC,OAAOe,WAAW;EACpB;EACA,MAAM,IAAItM,KAAK,CACb,6DACF,CAAC;AACH;AACA,SAAS0M,cAAcA,CAACC,gBAAgB,EAAEC,UAAU,EAAE3I,UAAU,EAAEK,IAAI,EAAEuI,eAAe,GAAG,KAAK,EAAE;EAC/F,IAAIvI,IAAI,KAAK,OAAO,IAAI,CAACuI,eAAe,EAAE;IACxC,MAAM,IAAI7M,KAAK,CAAC,wDAAwD,CAAC;EAC3E;EACA,IAAIsE,IAAI,KAAK,QAAQ,IAAIuI,eAAe,EAAE;IACxC,OAAOF,gBAAgB;EACzB;EACA,IAAIG,eAAe,GAAG,EAAE;EACxB,IAAIC,aAAa,GAAG,CAAC;EACrB,MAAMC,IAAI,GAAG1I,IAAI,KAAK,OAAO,GAAGsI,UAAU,CAAC7I,MAAM,GAAG6I,UAAU,CAACK,OAAO;EACtE,KAAK,IAAI9M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6M,IAAI,CAAChJ,MAAM,EAAE7D,CAAC,EAAE,EAAE;IACpC,MAAM+M,QAAQ,GAAGF,IAAI,CAAC7M,CAAC,CAAC;IACxB,MAAMuE,SAAS,GAAGT,UAAU,CAACP,IAAI,CAAEW,CAAC,IAAKA,CAAC,CAAC1F,EAAE,KAAKuO,QAAQ,CAAC;IAC3D,IAAI,CAACxI,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACJ,IAAI,MAAM,OAAO,EAAE;MAC7D,IAAIuI,eAAe,EAAE;QACnB,IAAIF,gBAAgB,CAAC3I,MAAM,KAAKgJ,IAAI,CAAChJ,MAAM,EAAE;UAC3C,MAAMlK,KAAK,GAAG6S,gBAAgB,CAACI,aAAa,CAAC;UAC7CD,eAAe,CAAC/K,IAAI,CAACjI,KAAK,CAAC;UAC3BiT,aAAa,EAAE;QACjB,CAAC,MAAM;UACLD,eAAe,CAAC/K,IAAI,CAAC,IAAI,CAAC;QAC5B;MACF,CAAC,MAAM;QACLgL,aAAa,EAAE;QACf;MACF;MACA;IACF,CAAC,MAAM;MACL,MAAMjT,KAAK,GAAG6S,gBAAgB,CAACI,aAAa,CAAC;MAC7CD,eAAe,CAAC/K,IAAI,CAACjI,KAAK,CAAC;MAC3BiT,aAAa,EAAE;IACjB;EACF;EACA,OAAOD,eAAe;AACxB;AACA,eAAeK,WAAWA,CAACtO,QAAQ,EAAEuG,IAAI,EAAExC,QAAQ,EAAE;EACnD,MAAMwK,IAAI,GAAG,IAAI;EACjB,MAAMC,2BAA2B,CAACD,IAAI,EAAEhI,IAAI,CAAC;EAC7C,MAAMkI,QAAQ,GAAG,MAAMxC,oBAAoB,CACzC1F,IAAI,EACJ,KAAK,CAAC,EACN,EAAE,EACF,IAAI,EACJxC,QACF,CAAC;EACD,MAAM2K,OAAO,GAAG,MAAMjE,OAAO,CAACC,GAAG,CAC/B+D,QAAQ,CAACpJ,GAAG,CAAC,OAAO;IAAE5E,IAAI;IAAE0J,IAAI;IAAE1E;EAAK,CAAC,KAAK;IAC3C,IAAI,CAAC0E,IAAI,EACP,OAAO;MAAE1J,IAAI;MAAEgF;IAAK,CAAC;IACvB,MAAM1E,QAAQ,GAAG,MAAMwN,IAAI,CAACnF,YAAY,CAACpJ,QAAQ,EAAE,CAACmK,IAAI,CAAC,CAAC;IAC1D,MAAMwE,QAAQ,GAAG5N,QAAQ,CAACuI,KAAK,IAAIvI,QAAQ,CAACuI,KAAK,CAAC,CAAC,CAAC;IACpD,OAAO;MACL7I,IAAI;MACJkO,QAAQ;MACRlJ,IAAI;MACJ+E,IAAI,EAAE,OAAOoD,IAAI,KAAK,WAAW,IAAIzD,IAAI,YAAYyD,IAAI,GAAGzD,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACK,IAAI,GAAG,KAAK;IACvG,CAAC;EACH,CAAC,CACH,CAAC;EACDkE,OAAO,CAAC9O,OAAO,CAAC,CAAC;IAAEa,IAAI;IAAEkO,QAAQ;IAAElJ,IAAI;IAAE+E;EAAK,CAAC,KAAK;IAClD,IAAI/E,IAAI,KAAK,SAAS,EAAE;MACtBkG,aAAa,CAACpF,IAAI,EAAEoI,QAAQ,EAAElO,IAAI,CAAC;IACrC,CAAC,MAAM,IAAIkO,QAAQ,EAAE;MACnB,MAAMhF,IAAI,GAAG,IAAIiB,QAAQ,CAAC;QAAEnK,IAAI,EAAEkO,QAAQ;QAAE5D,SAAS,EAAEP;MAAK,CAAC,CAAC;MAC9DmB,aAAa,CAACpF,IAAI,EAAEoD,IAAI,EAAElJ,IAAI,CAAC;IACjC;EACF,CAAC,CAAC;EACF,OAAO8F,IAAI;AACb;AACA,eAAeiI,2BAA2BA,CAACI,OAAO,EAAErI,IAAI,EAAE;EACxD,IAAItG,EAAE,EAAEwE,EAAE;EACV,MAAM/D,IAAI,GAAG,CAAC,CAACT,EAAE,GAAG2O,OAAO,CAACjO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGV,EAAE,CAACS,IAAI,MAAM,CAAC+D,EAAE,GAAGmK,OAAO,CAACjO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG8D,EAAE,CAAC4E,QAAQ,CAAC;EACzH,IAAI,CAAC3I,IAAI,EAAE;IACT,MAAM,IAAIS,KAAK,CAAC7C,kBAAkB,CAAC;EACrC;EACA,MAAMuQ,4BAA4B,CAACD,OAAO,EAAErI,IAAI,CAAC;AACnD;AACA,eAAesI,4BAA4BA,CAACD,OAAO,EAAErI,IAAI,EAAE9F,IAAI,GAAG,EAAE,EAAE;EACpE,KAAK,MAAMzF,GAAG,IAAIuL,IAAI,EAAE;IACtB,IAAIA,IAAI,CAACvL,GAAG,CAAC,YAAYoQ,OAAO,EAAE;MAChC,MAAM0D,sBAAsB,CAACF,OAAO,EAAErI,IAAI,EAAEvL,GAAG,CAAC;IAClD,CAAC,MAAM,IAAI,OAAOuL,IAAI,CAACvL,GAAG,CAAC,KAAK,QAAQ,IAAIuL,IAAI,CAACvL,GAAG,CAAC,KAAK,IAAI,EAAE;MAC9D,MAAM6T,4BAA4B,CAACD,OAAO,EAAErI,IAAI,CAACvL,GAAG,CAAC,EAAE,CAAC,GAAGyF,IAAI,EAAEzF,GAAG,CAAC,CAAC;IACxE;EACF;AACF;AACA,eAAe8T,sBAAsBA,CAACF,OAAO,EAAErI,IAAI,EAAEvL,GAAG,EAAE;EACxD,IAAIiF,EAAE,EAAEwE,EAAE;EACV,IAAIsK,QAAQ,GAAGxI,IAAI,CAACvL,GAAG,CAAC;EACxB,MAAM0F,IAAI,GAAG,CAAC,CAACT,EAAE,GAAG2O,OAAO,CAACjO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGV,EAAE,CAACS,IAAI,MAAM,CAAC+D,EAAE,GAAGmK,OAAO,CAACjO,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG8D,EAAE,CAAC4E,QAAQ,CAAC;EACzH,IAAI,CAAC3I,IAAI,EAAE;IACT,MAAM,IAAIS,KAAK,CAAC7C,kBAAkB,CAAC;EACrC;EACA,IAAI;IACF,IAAI0Q,UAAU;IACd,IAAIC,QAAQ;IACZ,IAAI,OAAOzD,OAAO,KAAK,WAAW,IAAIA,OAAO,CAACC,QAAQ,IAAID,OAAO,CAACC,QAAQ,CAACC,IAAI,EAAE;MAC/E,MAAMwD,EAAE,GAAG,MAAM,MAAM,CAAC,aAAa,CAAC;MACtC,MAAMzO,IAAI,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC;MACjCwO,QAAQ,GAAGxO,IAAI,CAAC0O,OAAO,CAAC3D,OAAO,CAAC4D,GAAG,CAAC,CAAC,EAAEL,QAAQ,CAACzD,IAAI,CAAC7K,IAAI,CAAC;MAC1DuO,UAAU,GAAG,MAAME,EAAE,CAACG,QAAQ,CAACJ,QAAQ,CAAC;IAC1C,CAAC,MAAM;MACL,MAAM,IAAI9N,KAAK,CAAC9C,mBAAmB,CAAC;IACtC;IACA,MAAMsL,IAAI,GAAG,IAAI+C,IAAI,CAAC,CAACsC,UAAU,CAAC,EAAE;MAAEvJ,IAAI,EAAE;IAA2B,CAAC,CAAC;IACzE,MAAM1E,QAAQ,GAAG,MAAM6N,OAAO,CAACxF,YAAY,CAAC1I,IAAI,EAAE,CAACiJ,IAAI,CAAC,CAAC;IACzD,MAAMgF,QAAQ,GAAG5N,QAAQ,CAACuI,KAAK,IAAIvI,QAAQ,CAACuI,KAAK,CAAC,CAAC,CAAC;IACpD,IAAIqF,QAAQ,EAAE;MACZ,MAAMW,QAAQ,GAAG,IAAI1E,QAAQ,CAAC;QAC5BnK,IAAI,EAAEkO,QAAQ;QACd5D,SAAS,EAAEgE,QAAQ,CAACzD,IAAI,CAACd,IAAI,IAAI;MACnC,CAAC,CAAC;MACFjE,IAAI,CAACvL,GAAG,CAAC,GAAGsU,QAAQ;IACtB;EACF,CAAC,CAAC,OAAOjJ,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC9H,yBAAyB,EAAE8H,KAAK,CAAC;EACjD;AACF;AACA,eAAekJ,SAASA,CAACtG,GAAG,EAAE3G,IAAI,EAAEkN,kBAAkB,EAAE;EACtD,MAAMrQ,OAAO,GAAG;IAAE,cAAc,EAAE;EAAmB,CAAC;EACtD,IAAI,IAAI,CAACe,OAAO,CAACC,QAAQ,EAAE;IACzBhB,OAAO,CAACC,aAAa,GAAG,UAAU,IAAI,CAACc,OAAO,CAACC,QAAQ,EAAE;EAC3D;EACA,IAAI;IACF,IAAIY,QAAQ,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC+J,GAAG,EAAE;MACnC5G,MAAM,EAAE,MAAM;MACdC,IAAI,EAAEwG,IAAI,CAACC,SAAS,CAACzG,IAAI,CAAC;MAC1BnD,OAAO,EAAE;QAAE,GAAGA,OAAO;QAAE,GAAGqQ;MAAmB,CAAC;MAC9CxO,WAAW,EAAE;IACf,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOxB,CAAC,EAAE;IACV,OAAO,CAAC;MAAE6G,KAAK,EAAEzI;IAAsB,CAAC,EAAE,GAAG,CAAC;EAChD;EACA,IAAI+J,MAAM;EACV,IAAI1G,MAAM;EACV,IAAI;IACF0G,MAAM,GAAG,MAAM5G,QAAQ,CAACxB,IAAI,CAAC,CAAC;IAC9B0B,MAAM,GAAGF,QAAQ,CAACE,MAAM;EAC1B,CAAC,CAAC,OAAOzB,CAAC,EAAE;IACVmI,MAAM,GAAG;MAAEtB,KAAK,EAAE,oCAAoC7G,CAAC;IAAG,CAAC;IAC3DyB,MAAM,GAAG,GAAG;EACd;EACA,OAAO,CAAC0G,MAAM,EAAE1G,MAAM,CAAC;AACzB;AACA,eAAewO,OAAOA,CAACzP,QAAQ,EAAEuG,IAAI,GAAG,CAAC,CAAC,EAAE;EAC1C,IAAImJ,aAAa,GAAG,KAAK;EACzB,IAAIC,eAAe,GAAG,KAAK;EAC3B,IAAI,CAAC,IAAI,CAAChP,MAAM,EAAE;IAChB,MAAM,IAAIQ,KAAK,CAAC,8BAA8B,CAAC;EACjD;EACA,IAAI,OAAOnB,QAAQ,KAAK,QAAQ,EAAE;IAChC,IAAI,CAACW,MAAM,CAACS,YAAY,CAACyD,IAAI,CAAExD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAIE,QAAQ,CAAC;EAC5D,CAAC,MAAM;IACL,MAAM4P,gBAAgB,GAAG5P,QAAQ,CAACuD,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IACpD,IAAI,CAAC5C,MAAM,CAACS,YAAY,CAACyD,IAAI,CAC1BxD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAI,IAAI,CAACkE,OAAO,CAAC4L,gBAAgB,CAClD,CAAC;EACH;EACA,OAAO,IAAInF,OAAO,CAAC,OAAO0E,OAAO,EAAEU,MAAM,KAAK;IAC5C,MAAMC,GAAG,GAAG,IAAI,CAACC,MAAM,CAAC/P,QAAQ,EAAEuG,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACzD,IAAIyJ,MAAM;IACV,WAAW,MAAMjO,OAAO,IAAI+N,GAAG,EAAE;MAC/B,IAAI/N,OAAO,CAAC0D,IAAI,KAAK,MAAM,EAAE;QAC3B,IAAIkK,eAAe,EAAE;UACnBR,OAAO,CAACa,MAAM,CAAC;QACjB;QACAN,aAAa,GAAG,IAAI;QACpBM,MAAM,GAAGjO,OAAO;MAClB;MACA,IAAIA,OAAO,CAAC0D,IAAI,KAAK,QAAQ,EAAE;QAC7B,IAAI1D,OAAO,CAACkF,KAAK,KAAK,OAAO,EAC3B4I,MAAM,CAAC9N,OAAO,CAAC;QACjB,IAAIA,OAAO,CAACkF,KAAK,KAAK,UAAU,EAAE;UAChC0I,eAAe,GAAG,IAAI;UACtB,IAAID,aAAa,EAAE;YACjBP,OAAO,CAACa,MAAM,CAAC;UACjB;QACF;MACF;IACF;EACF,CAAC,CAAC;AACJ;AACA,eAAeC,kBAAkBA,CAACnQ,EAAE,EAAE2F,IAAI,EAAEyK,eAAe,EAAE;EAC3D,IAAIlQ,QAAQ,GAAGyF,IAAI,KAAK,WAAW,GAAG,kDAAkD3F,EAAE,EAAE,GAAG,qCAAqCA,EAAE,EAAE;EACxI,IAAIiB,QAAQ;EACZ,IAAIoP,OAAO;EACX,IAAI;IACFpP,QAAQ,GAAG,MAAM7B,KAAK,CAACc,QAAQ,CAAC;IAChCmQ,OAAO,GAAGpP,QAAQ,CAACE,MAAM;IACzB,IAAIkP,OAAO,KAAK,GAAG,EAAE;MACnB,MAAM,IAAIhP,KAAK,CAAC,CAAC;IACnB;IACAJ,QAAQ,GAAG,MAAMA,QAAQ,CAACxB,IAAI,CAAC,CAAC;EAClC,CAAC,CAAC,OAAOC,CAAC,EAAE;IACV0Q,eAAe,CAAC;MACdjP,MAAM,EAAE,OAAO;MACfmP,WAAW,EAAE,OAAO;MACpBrO,OAAO,EAAEjE,sBAAsB;MAC/BuS,MAAM,EAAE;IACV,CAAC,CAAC;IACF;EACF;EACA,IAAI,CAACtP,QAAQ,IAAIoP,OAAO,KAAK,GAAG,EAC9B;EACF,MAAM;IACJG,OAAO,EAAE;MAAErJ;IAAM,CAAC;IAClBnH,EAAE,EAAEyQ;EACN,CAAC,GAAGxP,QAAQ;EACZ,QAAQkG,KAAK;IACX,KAAK,SAAS;IACd,KAAK,UAAU;MACbiJ,eAAe,CAAC;QACdjP,MAAM,EAAE,UAAU;QAClBmP,WAAW,EAAE,SAAS;QACtBrO,OAAO,EAAE,kCAAkC;QAC3CsO,MAAM,EAAEpJ;MACV,CAAC,CAAC;MACFuJ,UAAU,CAAC,MAAM;QACfP,kBAAkB,CAACnQ,EAAE,EAAE2F,IAAI,EAAEyK,eAAe,CAAC;MAC/C,CAAC,EAAE,GAAG,CAAC;MACP;IACF,KAAK,QAAQ;MACXA,eAAe,CAAC;QACdjP,MAAM,EAAE,QAAQ;QAChBmP,WAAW,EAAE,OAAO;QACpBrO,OAAO,EAAE,+GAA+G;QACxHsO,MAAM,EAAEpJ,KAAK;QACbwJ,mBAAmB,EAAE,MAAMA,mBAAmB,CAACF,UAAU;MAC3D,CAAC,CAAC;MACF;IACF,KAAK,SAAS;IACd,KAAK,kBAAkB;MACrBL,eAAe,CAAC;QACdjP,MAAM,EAAE,SAAS;QACjBmP,WAAW,EAAE,UAAU;QACvBrO,OAAO,EAAE,mBAAmB;QAC5BsO,MAAM,EAAEpJ;MACV,CAAC,CAAC;MACF;IACF,KAAK,UAAU;MACbiJ,eAAe,CAAC;QACdjP,MAAM,EAAE,UAAU;QAClBmP,WAAW,EAAE,SAAS;QACtBrO,OAAO,EAAE,sBAAsB;QAC/BsO,MAAM,EAAEpJ;MACV,CAAC,CAAC;MACFuJ,UAAU,CAAC,MAAM;QACfP,kBAAkB,CAACnQ,EAAE,EAAE2F,IAAI,EAAEyK,eAAe,CAAC;MAC/C,CAAC,EAAE,GAAG,CAAC;MACP;IACF,KAAK,cAAc;MACjBA,eAAe,CAAC;QACdjP,MAAM,EAAE,UAAU;QAClBmP,WAAW,EAAE,SAAS;QACtBrO,OAAO,EAAE,sBAAsB;QAC/BsO,MAAM,EAAEpJ;MACV,CAAC,CAAC;MACFuJ,UAAU,CAAC,MAAM;QACfP,kBAAkB,CAACnQ,EAAE,EAAE2F,IAAI,EAAEyK,eAAe,CAAC;MAC/C,CAAC,EAAE,GAAG,CAAC;MACP;IACF;MACEA,eAAe,CAAC;QACdjP,MAAM,EAAE,aAAa;QACrBmP,WAAW,EAAE,OAAO;QACpBrO,OAAO,EAAE,sCAAsC;QAC/CsO,MAAM,EAAEpJ,KAAK;QACbwJ,mBAAmB,EAAE,MAAMA,mBAAmB,CAACF,UAAU;MAC3D,CAAC,CAAC;MACF;EACJ;AACF;AACA,MAAMG,oBAAoB,GAAG,MAAAA,CAAOjN,QAAQ,EAAEyM,eAAe,KAAK;EAChE,IAAIS,OAAO,GAAG,CAAC;EACf,MAAMC,WAAW,GAAG,EAAE;EACtB,MAAMC,cAAc,GAAG,GAAG;EAC1B,OAAO,IAAIpG,OAAO,CAAE0E,OAAO,IAAK;IAC9Bc,kBAAkB,CAChBxM,QAAQ,EACRL,aAAa,CAAClG,IAAI,CAACuG,QAAQ,CAAC,GAAG,YAAY,GAAG,WAAW,EACxDxC,MAAM,IAAK;MACViP,eAAe,CAACjP,MAAM,CAAC;MACvB,IAAIA,MAAM,CAACA,MAAM,KAAK,SAAS,EAAE;QAC/BkO,OAAO,CAAC,CAAC;MACX,CAAC,MAAM,IAAIlO,MAAM,CAACA,MAAM,KAAK,OAAO,IAAIA,MAAM,CAACA,MAAM,KAAK,QAAQ,IAAIA,MAAM,CAACA,MAAM,KAAK,aAAa,EAAE;QACrGkO,OAAO,CAAC,CAAC;MACX,CAAC,MAAM,IAAIlO,MAAM,CAACA,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACA,MAAM,KAAK,UAAU,EAAE;QACvE,IAAI0P,OAAO,GAAGC,WAAW,EAAE;UACzBD,OAAO,EAAE;UACTH,UAAU,CAAC,MAAM;YACfE,oBAAoB,CAACjN,QAAQ,EAAEyM,eAAe,CAAC,CAACvF,IAAI,CAACwE,OAAO,CAAC;UAC/D,CAAC,EAAE0B,cAAc,CAAC;QACpB,CAAC,MAAM;UACL1B,OAAO,CAAC,CAAC;QACX;MACF;IACF,CACF,CAAC;EACH,CAAC,CAAC;AACJ,CAAC;AACD,MAAM2B,sBAAsB,GAAG,8DAA8D;AAC7F,eAAeL,mBAAmBA,CAAChN,QAAQ,EAAE;EAC3C,IAAI;IACF,MAAMxE,CAAC,GAAG,MAAMC,KAAK,CACnB,qCAAqCuE,QAAQ,cAAc,EAC3D;MACEpB,MAAM,EAAE;IACV,CACF,CAAC;IACD,MAAMgE,KAAK,GAAGpH,CAAC,CAACE,OAAO,CAACrD,GAAG,CAAC,iBAAiB,CAAC;IAC9C,IAAI,CAACmD,CAAC,CAACiK,EAAE,IAAI7C,KAAK,IAAIyK,sBAAsB,CAAC5T,IAAI,CAACmJ,KAAK,CAAC,EACtD,OAAO,KAAK;IACd,OAAO,IAAI;EACb,CAAC,CAAC,OAAO7G,CAAC,EAAE;IACV,OAAO,KAAK;EACd;AACF;AACA,eAAeuR,kBAAkBA,CAACtN,QAAQ,EAAEtD,QAAQ,EAAE;EACpD,MAAMhB,OAAO,GAAG,CAAC,CAAC;EAClB,IAAIgB,QAAQ,EAAE;IACZhB,OAAO,CAACC,aAAa,GAAG,UAAUe,QAAQ,EAAE;EAC9C;EACA,IAAI;IACF,MAAMiC,GAAG,GAAG,MAAMlD,KAAK,CACrB,qCAAqCuE,QAAQ,IAAIjG,WAAW,EAAE,EAC9D;MAAE2B;IAAQ,CACZ,CAAC;IACD,IAAIiD,GAAG,CAACnB,MAAM,KAAK,GAAG,EACpB,MAAM,IAAIE,KAAK,CAAC,uCAAuC,CAAC;IAC1D,MAAM;MAAE6P;IAAS,CAAC,GAAG,MAAM5O,GAAG,CAAC7C,IAAI,CAAC,CAAC;IACrC,OAAOyR,QAAQ,CAACC,OAAO;EACzB,CAAC,CAAC,OAAOzR,CAAC,EAAE;IACV,MAAM,IAAI2B,KAAK,CAAC3B,CAAC,CAACuC,OAAO,CAAC;EAC5B;AACF;AACA,eAAemP,iBAAiBA,CAACzN,QAAQ,EAAE0N,OAAO,EAAEhR,QAAQ,EAAE;EAC5D,MAAMhB,OAAO,GAAG,CAAC,CAAC;EAClB,IAAIgB,QAAQ,EAAE;IACZhB,OAAO,CAACC,aAAa,GAAG,UAAUe,QAAQ,EAAE;EAC9C;EACA,MAAMmC,IAAI,GAAG;IACX8O,OAAO,EAAED;EACX,CAAC;EACD,IAAI;IACF,MAAM/O,GAAG,GAAG,MAAMlD,KAAK,CACrB,qCAAqCuE,QAAQ,IAAIhG,aAAa,EAAE,EAChE;MACE4E,MAAM,EAAE,MAAM;MACdlD,OAAO,EAAE;QAAE,cAAc,EAAE,kBAAkB;QAAE,GAAGA;MAAQ,CAAC;MAC3DmD,IAAI,EAAEwG,IAAI,CAACC,SAAS,CAACzG,IAAI;IAC3B,CACF,CAAC;IACD,IAAIF,GAAG,CAACnB,MAAM,KAAK,GAAG,EAAE;MACtB,MAAM,IAAIE,KAAK,CACb,8IACF,CAAC;IACH;IACA,MAAMJ,QAAQ,GAAG,MAAMqB,GAAG,CAAC7C,IAAI,CAAC,CAAC;IACjC,OAAOwB,QAAQ;EACjB,CAAC,CAAC,OAAOvB,CAAC,EAAE;IACV,MAAM,IAAI2B,KAAK,CAAC3B,CAAC,CAACuC,OAAO,CAAC;EAC5B;AACF;AACA,MAAMsP,cAAc,GAAG,CACrB,WAAW,EACX,aAAa,EACb,QAAQ,EACR,UAAU,EACV,WAAW,EACX,YAAY,EACZ,YAAY,EACZ,cAAc,EACd,cAAc,EACd,YAAY,EACZ,WAAW,EACX,MAAM,EACN,QAAQ,CACT;AACD,eAAeC,SAASA,CAAC3P,aAAa,EAAEzB,OAAO,EAAE;EAC/C,MAAM;IAAEC,QAAQ;IAAEoR,OAAO,EAAEC,QAAQ;IAAER,QAAQ;IAAEG,OAAO;IAAEjQ;EAAK,CAAC,GAAGhB,OAAO;EACxE,IAAI8Q,QAAQ,IAAI,CAACK,cAAc,CAACI,QAAQ,CAACT,QAAQ,CAAC,EAAE;IAClD,MAAM,IAAI7P,KAAK,CACb,oDAAoDkQ,cAAc,CAAChM,GAAG,CAAEqM,CAAC,IAAK,IAAIA,CAAC,GAAG,CAAC,CAACzU,IAAI,CAAC,GAAG,CAAC,GACnG,CAAC;EACH;EACA,MAAM;IAAEuE,aAAa;IAAEC;EAAK,CAAC,GAAG,MAAMC,gBAAgB,CACpDC,aAAa,EACbxB,QACF,CAAC;EACD,IAAInB,OAAO,GAAG,IAAI;EAClB,IAAIkC,IAAI,EAAE;IACR,MAAMU,aAAa,GAAG,MAAMC,iBAAiB,CAC3CL,aAAa,EACbC,IAAI,EACJP,IAAI,EACJhC,KACF,CAAC;IACD,IAAI0C,aAAa,EACf5C,OAAO,GAAG6D,qBAAqB,CAACjB,aAAa,CAAC;EAClD;EACA,MAAMzC,OAAO,GAAG;IACdC,aAAa,EAAE,UAAUe,QAAQ,EAAE;IACnC,cAAc,EAAE,kBAAkB;IAClC,IAAGnB,OAAO,GAAG;MAAEK,MAAM,EAAEL,OAAO,CAAC/B,IAAI,CAAC,IAAI;IAAE,CAAC,GAAG,CAAC,CAAC;EAClD,CAAC;EACD,MAAM0U,IAAI,GAAG,CAAC,MAAM,CAAC,MAAMzS,KAAK,CAAC,sCAAsC,EAAE;IACvEC;EACF,CAAC,CAAC,EAAEI,IAAI,CAAC,CAAC,EAAEiL,IAAI;EAChB,MAAM+F,UAAU,GAAG5O,aAAa,CAAC5E,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC9C,MAAMuF,IAAI,GAAG;IACXsP,UAAU,EAAE,GAAGD,IAAI,IAAIpB,UAAU;EACnC,CAAC;EACD,IAAIiB,QAAQ,EAAE;IACZlP,IAAI,CAACiP,OAAO,GAAG,IAAI;EACrB;EACA,IAAIM,iBAAiB;EACrB,IAAI;IACF,IAAI,CAACb,QAAQ,EAAE;MACba,iBAAiB,GAAG,MAAMd,kBAAkB,CAACpP,aAAa,EAAExB,QAAQ,CAAC;IACvE;EACF,CAAC,CAAC,OAAOX,CAAC,EAAE;IACV,MAAM2B,KAAK,CAACnD,wBAAwB,GAAGwB,CAAC,CAACuC,OAAO,CAAC;EACnD;EACA,MAAM+P,kBAAkB,GAAGd,QAAQ,IAAIa,iBAAiB,IAAI,WAAW;EACvEvP,IAAI,CAAC0O,QAAQ,GAAGc,kBAAkB;EAClC,IAAI;IACF,MAAM/Q,QAAQ,GAAG,MAAM7B,KAAK,CAC1B,qCAAqCyC,aAAa,YAAY,EAC9D;MACEU,MAAM,EAAE,MAAM;MACdlD,OAAO;MACPmD,IAAI,EAAEwG,IAAI,CAACC,SAAS,CAACzG,IAAI;IAC3B,CACF,CAAC;IACD,IAAIvB,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAE;MAC3B,IAAI;QACF,MAAM2N,OAAO,GAAG,MAAMmD,MAAM,CAACC,OAAO,CAAC,GAAGL,IAAI,IAAIpB,UAAU,EAAE,EAAErQ,OAAO,CAAC;QACtE,OAAO0O,OAAO;MAChB,CAAC,CAAC,OAAOvI,KAAK,EAAE;QACdD,OAAO,CAACC,KAAK,CAAC,oCAAoC,EAAEA,KAAK,CAAC;QAC1D,MAAMA,KAAK;MACb;IACF,CAAC,MAAM,IAAItF,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAE;MAClC,MAAM,IAAIE,KAAK,CAACJ,QAAQ,CAACkR,UAAU,CAAC;IACtC;IACA,MAAMC,gBAAgB,GAAG,MAAMnR,QAAQ,CAACxB,IAAI,CAAC,CAAC;IAC9C,MAAM2R,iBAAiB,CAAC,GAAGS,IAAI,IAAIpB,UAAU,EAAE,EAAEY,OAAO,IAAI,GAAG,EAAEhR,QAAQ,CAAC;IAC1E,OAAO,MAAM4R,MAAM,CAACC,OAAO,CACzBG,mBAAmB,CAACD,gBAAgB,CAACjJ,GAAG,CAAC,EACzC/I,OACF,CAAC;EACH,CAAC,CAAC,OAAOV,CAAC,EAAE;IACV,MAAM,IAAI2B,KAAK,CAAC3B,CAAC,CAAC;EACpB;AACF;AACA,SAAS2S,mBAAmBA,CAAClJ,GAAG,EAAE;EAChC,MAAMmJ,KAAK,GAAG,kDAAkD;EAChE,MAAMC,KAAK,GAAGpJ,GAAG,CAACoJ,KAAK,CAACD,KAAK,CAAC;EAC9B,IAAIC,KAAK,EAAE;IACT,OAAOA,KAAK,CAAC,CAAC,CAAC;EACjB;AACF;AACA,MAAMC,cAAc,SAASC,eAAe,CAAC;EAC3C;EACAtH,WAAWA,CAAC/K,OAAO,GAAG;IAAEsS,OAAO,EAAE;EAAM,CAAC,EAAE;IACxC,KAAK,CAAC;MACJC,SAAS,EAAEA,CAACC,KAAK,EAAEC,UAAU,KAAK;QAChCD,KAAK,GAAG/W,YAAY,CAAC,IAAI,EAAEU,YAAY,CAAC,GAAGqW,KAAK;QAChD,OAAO,IAAI,EAAE;UACX,MAAME,OAAO,GAAGF,KAAK,CAACG,OAAO,CAAC,IAAI,CAAC;UACnC,MAAMC,OAAO,GAAG5S,OAAO,CAACsS,OAAO,GAAGE,KAAK,CAACG,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;UAC1D,IAAIC,OAAO,KAAK,CAAC,CAAC,IAAIA,OAAO,KAAKJ,KAAK,CAACvN,MAAM,GAAG,CAAC,KAAKyN,OAAO,KAAK,CAAC,CAAC,IAAIA,OAAO,GAAG,CAAC,GAAGE,OAAO,CAAC,EAAE;YAC/FH,UAAU,CAACI,OAAO,CAACL,KAAK,CAAC1V,KAAK,CAAC,CAAC,EAAE8V,OAAO,CAAC,CAAC;YAC3CJ,KAAK,GAAGA,KAAK,CAAC1V,KAAK,CAAC8V,OAAO,GAAG,CAAC,CAAC;YAChC;UACF;UACA,IAAIF,OAAO,KAAK,CAAC,CAAC,EAChB;UACF,MAAMI,QAAQ,GAAGN,KAAK,CAACE,OAAO,GAAG,CAAC,CAAC,KAAK,IAAI,GAAGA,OAAO,GAAG,CAAC,GAAGA,OAAO;UACpED,UAAU,CAACI,OAAO,CAACL,KAAK,CAAC1V,KAAK,CAAC,CAAC,EAAEgW,QAAQ,CAAC,CAAC;UAC5CN,KAAK,GAAGA,KAAK,CAAC1V,KAAK,CAAC4V,OAAO,GAAG,CAAC,CAAC;QAClC;QACAzW,YAAY,CAAC,IAAI,EAAEE,YAAY,EAAEqW,KAAK,CAAC;MACzC,CAAC;MACDO,KAAK,EAAGN,UAAU,IAAK;QACrB,IAAIhX,YAAY,CAAC,IAAI,EAAEU,YAAY,CAAC,KAAK,EAAE,EACzC;QACF,MAAM6W,WAAW,GAAGhT,OAAO,CAACsS,OAAO,IAAI7W,YAAY,CAAC,IAAI,EAAEU,YAAY,CAAC,CAACsG,QAAQ,CAAC,IAAI,CAAC,GAAGhH,YAAY,CAAC,IAAI,EAAEU,YAAY,CAAC,CAACW,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAGrB,YAAY,CAAC,IAAI,EAAEU,YAAY,CAAC;QACzKsW,UAAU,CAACI,OAAO,CAACG,WAAW,CAAC;MACjC;IACF,CAAC,CAAC;IACFnX,YAAY,CAAC,IAAI,EAAEM,YAAY,EAAE,EAAE,CAAC;EACtC;AACF;AACAA,YAAY,GAAG,IAAI8W,OAAO,CAAC,CAAC;AAC5B,SAASC,QAAQA,CAAC9N,KAAK,EAAE;EACvB,IAAI+N,OAAO,GAAG,IAAIC,iBAAiB,CAAC,CAAC;EACrC,IAAIC,MAAM,GAAG,IAAIjB,cAAc,CAAC;IAAEE,OAAO,EAAE;EAAK,CAAC,CAAC;EAClD,OAAOlN,KAAK,CAACkO,WAAW,CAACH,OAAO,CAAC,CAACG,WAAW,CAACD,MAAM,CAAC;AACvD;AACA,SAASxW,KAAKA,CAACuI,KAAK,EAAE;EACpB,IAAImO,GAAG,GAAG,QAAQ;EAClB,IAAIpB,KAAK,GAAGoB,GAAG,CAACC,IAAI,CAACpO,KAAK,CAAC;EAC3B,IAAIK,GAAG,GAAG0M,KAAK,IAAIA,KAAK,CAAC7J,KAAK;EAC9B,IAAI7C,GAAG,EAAE;IACP,OAAO,CACLL,KAAK,CAACqO,SAAS,CAAC,CAAC,EAAEhO,GAAG,CAAC,EACvBL,KAAK,CAACqO,SAAS,CAAChO,GAAG,GAAG0M,KAAK,CAAC,CAAC,CAAC,CAAClN,MAAM,CAAC,CACvC;EACH;AACF;AACA,SAASyO,QAAQA,CAACzU,OAAO,EAAEnE,GAAG,EAAEC,KAAK,EAAE;EACrC,IAAI4Y,GAAG,GAAG1U,OAAO,CAACrD,GAAG,CAACd,GAAG,CAAC;EAC1B,IAAI,CAAC6Y,GAAG,EACN1U,OAAO,CAACjD,GAAG,CAAClB,GAAG,EAAEC,KAAK,CAAC;AAC3B;AACA,gBAAgB6Y,MAAMA,CAAC1R,GAAG,EAAE2R,MAAM,EAAE;EAClC,IAAI,CAAC3R,GAAG,CAACE,IAAI,EACX;EACF,IAAI0R,IAAI,GAAGZ,QAAQ,CAAChR,GAAG,CAACE,IAAI,CAAC;EAC7B,IAAI2R,IAAI;IAAEC,MAAM,GAAGF,IAAI,CAACG,SAAS,CAAC,CAAC;EACnC,IAAIC,KAAK;EACT,SAAW;IACT,IAAIL,MAAM,IAAIA,MAAM,CAACM,OAAO,EAAE;MAC5B,OAAOH,MAAM,CAACjP,MAAM,CAAC,CAAC;IACxB;IACAgP,IAAI,GAAG,MAAMC,MAAM,CAACI,IAAI,CAAC,CAAC;IAC1B,IAAIL,IAAI,CAACM,IAAI,EACX;IACF,IAAI,CAACN,IAAI,CAAChZ,KAAK,EAAE;MACf,IAAImZ,KAAK,EACP,MAAMA,KAAK;MACbA,KAAK,GAAG,KAAK,CAAC;MACd;IACF;IACA,IAAI,CAACI,KAAK,EAAEvZ,KAAK,CAAC,GAAG8B,KAAK,CAACkX,IAAI,CAAChZ,KAAK,CAAC,IAAI,EAAE;IAC5C,IAAI,CAACuZ,KAAK,EACR;IACF,IAAIA,KAAK,KAAK,MAAM,EAAE;MACpBJ,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC;MACrBA,KAAK,CAACI,KAAK,CAAC,GAAGJ,KAAK,CAACI,KAAK,CAAC,GAAGJ,KAAK,CAACI,KAAK,CAAC,GAAG,IAAI,GAAGvZ,KAAK,GAAGA,KAAK;IACnE,CAAC,MAAM,IAAIuZ,KAAK,KAAK,OAAO,EAAE;MAC5BJ,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC;MACrBA,KAAK,CAACI,KAAK,CAAC,GAAGvZ,KAAK;IACtB,CAAC,MAAM,IAAIuZ,KAAK,KAAK,IAAI,EAAE;MACzBJ,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC;MACrBA,KAAK,CAACI,KAAK,CAAC,GAAG,CAACvZ,KAAK,IAAIA,KAAK;IAChC,CAAC,MAAM,IAAIuZ,KAAK,KAAK,OAAO,EAAE;MAC5BJ,KAAK,KAAKA,KAAK,GAAG,CAAC,CAAC,CAAC;MACrBA,KAAK,CAACI,KAAK,CAAC,GAAG,CAACvZ,KAAK,IAAI,KAAK,CAAC;IACjC;EACF;AACF;AACA,eAAewZ,MAAMA,CAACnP,KAAK,EAAEoP,IAAI,EAAE;EACjC,IAAIC,GAAG,GAAG,IAAIC,OAAO,CAACtP,KAAK,EAAEoP,IAAI,CAAC;EAClCd,QAAQ,CAACe,GAAG,CAACxV,OAAO,EAAE,QAAQ,EAAE,mBAAmB,CAAC;EACpDyU,QAAQ,CAACe,GAAG,CAACxV,OAAO,EAAE,cAAc,EAAE,kBAAkB,CAAC;EACzD,IAAIF,CAAC,GAAG,MAAMC,KAAK,CAACyV,GAAG,CAAC;EACxB,IAAI,CAAC1V,CAAC,CAACiK,EAAE,EACP,MAAMjK,CAAC;EACT,OAAO6U,MAAM,CAAC7U,CAAC,EAAE0V,GAAG,CAACZ,MAAM,CAAC;AAC9B;AACA,eAAec,WAAWA,CAAA,EAAG;EAC3B,IAAI;IACFC,eAAe;IACfC,eAAe;IACfC,uBAAuB;IACvBC,aAAa;IACbtU,MAAM;IACNrB;EACF,CAAC,GAAG,IAAI;EACR,MAAM4V,IAAI,GAAG,IAAI;EACjB,IAAI,CAACvU,MAAM,EAAE;IACX,MAAM,IAAIQ,KAAK,CAAC,8BAA8B,CAAC;EACjD;EACA8T,aAAa,CAACE,IAAI,GAAG,IAAI;EACzB,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,MAAM,GAAG,IAAIC,eAAe,CAAC;IAC/BC,YAAY,EAAE,IAAI,CAACA;EACrB,CAAC,CAAC,CAAC1R,QAAQ,CAAC,CAAC;EACb,IAAIoF,GAAG,GAAG,IAAIvG,GAAG,CAAC,GAAG/B,MAAM,CAACD,IAAI,eAAe2U,MAAM,EAAE,CAAC;EACxD,IAAI/V,GAAG,EAAE;IACP2J,GAAG,CAACuM,YAAY,CAACtZ,GAAG,CAAC,QAAQ,EAAEoD,GAAG,CAAC;EACrC;EACA8V,OAAO,GAAG,IAAI,CAACX,MAAM,CAACxL,GAAG,CAAC;EAC1B,IAAI,CAACmM,OAAO,EAAE;IACZhP,OAAO,CAACgC,IAAI,CAAC,kCAAkC,GAAGa,GAAG,CAACpF,QAAQ,CAAC,CAAC,CAAC;IACjE;EACF;EACAuR,OAAO,CAACjI,SAAS,GAAG,gBAAeiH,KAAK,EAAE;IACxC,IAAIqB,KAAK,GAAG3M,IAAI,CAAC4M,KAAK,CAACtB,KAAK,CAAC7N,IAAI,CAAC;IAClC,IAAIkP,KAAK,CAACja,GAAG,KAAK,cAAc,EAAE;MAChCma,YAAY,CAACV,aAAa,EAAEC,IAAI,CAACU,gBAAgB,CAAC;MAClD;IACF;IACA,MAAMC,QAAQ,GAAGJ,KAAK,CAACI,QAAQ;IAC/B,IAAI,CAACA,QAAQ,EAAE;MACb,MAAMpL,OAAO,CAACC,GAAG,CACf9P,MAAM,CAACwJ,IAAI,CAAC0Q,eAAe,CAAC,CAACzP,GAAG,CAC7ByQ,SAAS,IAAKhB,eAAe,CAACgB,SAAS,CAAC,CAACL,KAAK,CACjD,CACF,CAAC;IACH,CAAC,MAAM,IAAIX,eAAe,CAACe,QAAQ,CAAC,IAAIlV,MAAM,EAAE;MAC9C,IAAI8U,KAAK,CAACja,GAAG,KAAK,mBAAmB,IAAI,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,EAAE,QAAQ,CAAC,CAACiW,QAAQ,CACjG9Q,MAAM,CAAC6B,QACT,CAAC,EAAE;QACDuS,eAAe,CAACgB,MAAM,CAACF,QAAQ,CAAC;MAClC;MACA,IAAIG,GAAG,GAAGlB,eAAe,CAACe,QAAQ,CAAC;MACnC,IAAI,OAAOzV,MAAM,KAAK,WAAW,IAAI,OAAO6V,QAAQ,KAAK,WAAW,EAAE;QACpEzF,UAAU,CAACwF,GAAG,EAAE,CAAC,EAAEP,KAAK,CAAC;MAC3B,CAAC,MAAM;QACLO,GAAG,CAACP,KAAK,CAAC;MACZ;IACF,CAAC,MAAM;MACL,IAAI,CAACT,uBAAuB,CAACa,QAAQ,CAAC,EAAE;QACtCb,uBAAuB,CAACa,QAAQ,CAAC,GAAG,EAAE;MACxC;MACAb,uBAAuB,CAACa,QAAQ,CAAC,CAAC3S,IAAI,CAACuS,KAAK,CAAC;IAC/C;EACF,CAAC;EACDL,OAAO,CAACc,OAAO,GAAG,kBAAiB;IACjC,MAAMzL,OAAO,CAACC,GAAG,CACf9P,MAAM,CAACwJ,IAAI,CAAC0Q,eAAe,CAAC,CAACzP,GAAG,CAC7BwQ,QAAQ,IAAKf,eAAe,CAACe,QAAQ,CAAC,CAAC;MACtCra,GAAG,EAAE,kBAAkB;MACvBuG,OAAO,EAAEnE;IACX,CAAC,CACH,CACF,CAAC;EACH,CAAC;AACH;AACA,SAAS+X,YAAYA,CAACV,aAAa,EAAEW,gBAAgB,EAAE;EACrD,IAAIX,aAAa,EAAE;IACjBA,aAAa,CAACE,IAAI,GAAG,KAAK;IAC1BS,gBAAgB,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACO,KAAK,CAAC,CAAC;EAC9D;AACF;AACA,SAASC,iBAAiBA,CAACC,oBAAoB,EAAER,QAAQ,EAAEtP,IAAI,EAAE;EAC/D,IAAI+P,mBAAmB,GAAG,CAACD,oBAAoB,CAACR,QAAQ,CAAC;EACzD,IAAIS,mBAAmB,EAAE;IACvBD,oBAAoB,CAACR,QAAQ,CAAC,GAAG,EAAE;IACnCtP,IAAI,CAACA,IAAI,CAAC3G,OAAO,CAAC,CAAC3E,KAAK,EAAEqG,CAAC,KAAK;MAC9B+U,oBAAoB,CAACR,QAAQ,CAAC,CAACvU,CAAC,CAAC,GAAGrG,KAAK;IAC3C,CAAC,CAAC;EACJ,CAAC,MAAM;IACLsL,IAAI,CAACA,IAAI,CAAC3G,OAAO,CAAC,CAAC3E,KAAK,EAAEqG,CAAC,KAAK;MAC9B,IAAIiV,QAAQ,GAAGC,UAAU,CAACH,oBAAoB,CAACR,QAAQ,CAAC,CAACvU,CAAC,CAAC,EAAErG,KAAK,CAAC;MACnEob,oBAAoB,CAACR,QAAQ,CAAC,CAACvU,CAAC,CAAC,GAAGiV,QAAQ;MAC5ChQ,IAAI,CAACA,IAAI,CAACjF,CAAC,CAAC,GAAGiV,QAAQ;IACzB,CAAC,CAAC;EACJ;AACF;AACA,SAASC,UAAUA,CAACzb,GAAG,EAAE0b,IAAI,EAAE;EAC7BA,IAAI,CAAC7W,OAAO,CAAC,CAAC,CAAC8W,MAAM,EAAEjW,IAAI,EAAExF,KAAK,CAAC,KAAK;IACtCF,GAAG,GAAG4b,UAAU,CAAC5b,GAAG,EAAE0F,IAAI,EAAEiW,MAAM,EAAEzb,KAAK,CAAC;EAC5C,CAAC,CAAC;EACF,OAAOF,GAAG;AACZ;AACA,SAAS4b,UAAUA,CAACC,MAAM,EAAEnW,IAAI,EAAEiW,MAAM,EAAEzb,KAAK,EAAE;EAC/C,IAAIwF,IAAI,CAAC0E,MAAM,KAAK,CAAC,EAAE;IACrB,IAAIuR,MAAM,KAAK,SAAS,EAAE;MACxB,OAAOzb,KAAK;IACd,CAAC,MAAM,IAAIyb,MAAM,KAAK,QAAQ,EAAE;MAC9B,OAAOE,MAAM,GAAG3b,KAAK;IACvB;IACA,MAAM,IAAIkG,KAAK,CAAC,uBAAuBuV,MAAM,EAAE,CAAC;EAClD;EACA,IAAIzF,OAAO,GAAG2F,MAAM;EACpB,KAAK,IAAItV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAAC0E,MAAM,GAAG,CAAC,EAAE7D,CAAC,EAAE,EAAE;IACxC2P,OAAO,GAAGA,OAAO,CAACxQ,IAAI,CAACa,CAAC,CAAC,CAAC;EAC5B;EACA,MAAMuV,SAAS,GAAGpW,IAAI,CAACA,IAAI,CAAC0E,MAAM,GAAG,CAAC,CAAC;EACvC,QAAQuR,MAAM;IACZ,KAAK,SAAS;MACZzF,OAAO,CAAC4F,SAAS,CAAC,GAAG5b,KAAK;MAC1B;IACF,KAAK,QAAQ;MACXgW,OAAO,CAAC4F,SAAS,CAAC,IAAI5b,KAAK;MAC3B;IACF,KAAK,KAAK;MACR,IAAIiN,KAAK,CAACC,OAAO,CAAC8I,OAAO,CAAC,EAAE;QAC1BA,OAAO,CAAC9K,MAAM,CAAC2Q,MAAM,CAACD,SAAS,CAAC,EAAE,CAAC,EAAE5b,KAAK,CAAC;MAC7C,CAAC,MAAM;QACLgW,OAAO,CAAC4F,SAAS,CAAC,GAAG5b,KAAK;MAC5B;MACA;IACF,KAAK,QAAQ;MACX,IAAIiN,KAAK,CAACC,OAAO,CAAC8I,OAAO,CAAC,EAAE;QAC1BA,OAAO,CAAC9K,MAAM,CAAC2Q,MAAM,CAACD,SAAS,CAAC,EAAE,CAAC,CAAC;MACtC,CAAC,MAAM;QACL,OAAO5F,OAAO,CAAC4F,SAAS,CAAC;MAC3B;MACA;IACF;MACE,MAAM,IAAI1V,KAAK,CAAC,mBAAmBuV,MAAM,EAAE,CAAC;EAChD;EACA,OAAOE,MAAM;AACf;AACA,SAASG,eAAeA,CAACzR,KAAK,EAAEoP,IAAI,GAAG,CAAC,CAAC,EAAE;EACzC,MAAMsC,QAAQ,GAAG;IACf5J,KAAK,EAAEA,CAAA,KAAM;MACXhH,OAAO,CAACgC,IAAI,CAAC,yBAAyB,CAAC;IACzC,CAAC;IACD8N,OAAO,EAAE,IAAI;IACb/I,SAAS,EAAE,IAAI;IACf8J,MAAM,EAAE,IAAI;IACZC,UAAU,EAAE,CAAC;IACbjO,GAAG,EAAE3D,KAAK,CAACzB,QAAQ,CAAC,CAAC;IACrBsT,eAAe,EAAE,KAAK;IACtBC,UAAU,EAAE,CAAC;IACbC,IAAI,EAAE,CAAC;IACPC,MAAM,EAAE,CAAC;IACTC,gBAAgB,EAAEA,CAAA,KAAM;MACtB,MAAM,IAAIpW,KAAK,CAAC,yBAAyB,CAAC;IAC5C,CAAC;IACDqW,aAAa,EAAEA,CAAA,KAAM;MACnB,MAAM,IAAIrW,KAAK,CAAC,yBAAyB,CAAC;IAC5C,CAAC;IACDsW,mBAAmB,EAAEA,CAAA,KAAM;MACzB,MAAM,IAAItW,KAAK,CAAC,yBAAyB,CAAC;IAC5C;EACF,CAAC;EACDsT,MAAM,CAACnP,KAAK,EAAEoP,IAAI,CAAC,CAAC/J,IAAI,CAAC,MAAOvI,GAAG,IAAK;IACtC4U,QAAQ,CAACE,UAAU,GAAGF,QAAQ,CAACK,IAAI;IACnC,IAAI;MACF,WAAW,MAAM3N,KAAK,IAAItH,GAAG,EAAE;QAC7B4U,QAAQ,CAAC7J,SAAS,IAAI6J,QAAQ,CAAC7J,SAAS,CAACzD,KAAK,CAAC;MACjD;MACAsN,QAAQ,CAACE,UAAU,GAAGF,QAAQ,CAACM,MAAM;IACvC,CAAC,CAAC,OAAO9X,CAAC,EAAE;MACVwX,QAAQ,CAACd,OAAO,IAAIc,QAAQ,CAACd,OAAO,CAAC1W,CAAC,CAAC;MACvCwX,QAAQ,CAACE,UAAU,GAAGF,QAAQ,CAACM,MAAM;IACvC;EACF,CAAC,CAAC,CAACI,KAAK,CAAElY,CAAC,IAAK;IACd4G,OAAO,CAACC,KAAK,CAAC7G,CAAC,CAAC;IAChBwX,QAAQ,CAACd,OAAO,IAAIc,QAAQ,CAACd,OAAO,CAAC1W,CAAC,CAAC;IACvCwX,QAAQ,CAACE,UAAU,GAAGF,QAAQ,CAACM,MAAM;EACvC,CAAC,CAAC;EACF,OAAON,QAAQ;AACjB;AACA,SAASjH,MAAMA,CAAC/P,QAAQ,EAAEuG,IAAI,GAAG,CAAC,CAAC,EAAEoR,UAAU,EAAEC,UAAU,EAAEC,UAAU,EAAE;EACvE,IAAI5X,EAAE;EACN,IAAI;IACF,IAAI6X,UAAU,GAAG,SAAAA,CAAS1D,KAAK,EAAE;QAC/B,IAAIyD,UAAU,IAAIE,iBAAiB,CAAC3D,KAAK,CAAC3O,IAAI,CAAC,EAAE;UAC/CuS,UAAU,CAAC5D,KAAK,CAAC;QACnB;MACF,CAAC;MAAEhH,KAAK,GAAG,SAAAA,CAAA,EAAW;QACpBmH,IAAI,GAAG,IAAI;QACX,OAAO0D,SAAS,CAAC9S,MAAM,GAAG,CAAC,EACzB8S,SAAS,CAACjM,KAAK,CAAC,CAAC,CAAC;UAChB/Q,KAAK,EAAE,KAAK,CAAC;UACbsZ,IAAI,EAAE;QACR,CAAC,CAAC;MACN,CAAC;MAAErR,IAAI,GAAG,SAAAA,CAASgV,KAAK,EAAE;QACxB,IAAI3D,IAAI,EACN;QACF,IAAI0D,SAAS,CAAC9S,MAAM,GAAG,CAAC,EAAE;UACxB8S,SAAS,CAACjM,KAAK,CAAC,CAAC,CAACkM,KAAK,CAAC;QAC1B,CAAC,MAAM;UACLC,MAAM,CAACjV,IAAI,CAACgV,KAAK,CAAC;QACpB;MACF,CAAC;MAAEE,UAAU,GAAG,SAAAA,CAAS/R,KAAK,EAAE;QAC9BnD,IAAI,CAACmV,eAAe,CAAChS,KAAK,CAAC,CAAC;QAC5B+G,KAAK,CAAC,CAAC;MACT,CAAC;MAAE4K,UAAU,GAAG,SAAAA,CAAS5D,KAAK,EAAE;QAC9BlR,IAAI,CAAC;UAAEjI,KAAK,EAAEmZ,KAAK;UAAEG,IAAI,EAAE;QAAM,CAAC,CAAC;MACrC,CAAC;MAAE+D,IAAI,GAAG,SAAAA,CAAA,EAAW;QACnB,IAAIH,MAAM,CAAChT,MAAM,GAAG,CAAC,EACnB,OAAOsF,OAAO,CAAC0E,OAAO,CAACgJ,MAAM,CAACnM,KAAK,CAAC,CAAC,CAAC;QACxC,IAAIuI,IAAI,EACN,OAAO9J,OAAO,CAAC0E,OAAO,CAAC;UAAElU,KAAK,EAAE,KAAK,CAAC;UAAEsZ,IAAI,EAAE;QAAK,CAAC,CAAC;QACvD,OAAO,IAAI9J,OAAO,CAAE0E,OAAO,IAAK8I,SAAS,CAAC/U,IAAI,CAACiM,OAAO,CAAC,CAAC;MAC1D,CAAC;IACD,MAAM;MAAEhP;IAAS,CAAC,GAAG,IAAI,CAACD,OAAO;IACjC,MAAM;MACJhB,KAAK,EAAEqZ,MAAM;MACb5W,aAAa;MACbhB,MAAM;MACN4U,YAAY;MACZxR,QAAQ;MACRC,OAAO;MACPiR,aAAa;MACbD,uBAAuB;MACvBqB,oBAAoB;MACpBvB,eAAe;MACfC,eAAe;MACfxF,SAAS,EAAEiJ,UAAU;MACrBtY;IACF,CAAC,GAAG,IAAI;IACR,MAAMgV,IAAI,GAAG,IAAI;IACjB,IAAI,CAACnR,QAAQ,EACX,MAAM,IAAI5C,KAAK,CAAC,cAAc,CAAC;IACjC,IAAI,CAACR,MAAM,EACT,MAAM,IAAIQ,KAAK,CAAC,8BAA8B,CAAC;IACjD,IAAI;MAAEsX,QAAQ;MAAExQ,aAAa;MAAE8F;IAAW,CAAC,GAAG2K,iBAAiB,CAC7D3U,QAAQ,EACR/D,QAAQ,EACRgE,OAAO,EACPrD,MACF,CAAC;IACD,IAAI0H,aAAa,GAAGL,kBAAkB,CAACzB,IAAI,EAAE0B,aAAa,CAAC;IAC3D,IAAI0Q,SAAS;IACb,IAAIvD,OAAO;IACX,IAAI5S,QAAQ,GAAG7B,MAAM,CAAC6B,QAAQ,IAAI,IAAI;IACtC,MAAMoW,SAAS,GAAG,OAAO5Y,QAAQ,KAAK,QAAQ,GAAG,UAAU,GAAGA,QAAQ;IACtE,IAAI6Y,OAAO;IACX,IAAIhD,QAAQ,GAAG,IAAI;IACnB,IAAIiD,QAAQ,GAAG,KAAK;IACpB,IAAI/R,WAAW,GAAG,CAAC,CAAC;IACpB,IAAIgS,UAAU,GAAG,OAAO3Y,MAAM,KAAK,WAAW,IAAI,OAAO6V,QAAQ,KAAK,WAAW,GAAG,IAAIX,eAAe,CAAClV,MAAM,CAACE,QAAQ,CAAC0Y,MAAM,CAAC,CAACnV,QAAQ,CAAC,CAAC,GAAG,EAAE;IAC/I,MAAMkU,iBAAiB,GAAG,CAAC,CAAC9X,EAAE,GAAGC,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC4T,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG7T,EAAE,CAAC0D,MAAM,CACtG,CAACsV,GAAG,EAAE7E,KAAK,KAAK;MACd6E,GAAG,CAAC7E,KAAK,CAAC,GAAG,IAAI;MACjB,OAAO6E,GAAG;IACZ,CAAC,EACD,CAAC,CACH,CAAC,KAAK,CAAC,CAAC;IACR,eAAehU,MAAMA,CAAA,EAAG;MACtB,MAAMkL,OAAO,GAAG;QACdlJ,KAAK,EAAE,UAAU;QACjBD,KAAK,EAAE,KAAK;QACZkS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;MACjC,CAAC;MACDL,QAAQ,GAAG3I,OAAO;MAClB2H,UAAU,CAAC;QACT,GAAG3H,OAAO;QACV1K,IAAI,EAAE,QAAQ;QACdzF,QAAQ,EAAE4Y,SAAS;QACnBH;MACF,CAAC,CAAC;MACF,IAAIW,aAAa,GAAG,CAAC,CAAC;MACtB,IAAIC,cAAc,GAAG,CAAC,CAAC;MACvB,IAAI7W,QAAQ,KAAK,IAAI,EAAE;QACrB,IAAImW,SAAS,IAAIA,SAAS,CAACzB,UAAU,KAAK,CAAC,EAAE;UAC3CyB,SAAS,CAACpB,gBAAgB,CAAC,MAAM,EAAE,MAAM;YACvCoB,SAAS,CAACvL,KAAK,CAAC,CAAC;UACnB,CAAC,CAAC;QACJ,CAAC,MAAM;UACLuL,SAAS,CAACvL,KAAK,CAAC,CAAC;QACnB;QACAgM,aAAa,GAAG;UAAEX,QAAQ;UAAElD;QAAa,CAAC;MAC5C,CAAC,MAAM;QACLI,YAAY,CAACV,aAAa,EAAEC,IAAI,CAACU,gBAAgB,CAAC;QAClDxI,KAAK,CAAC,CAAC;QACPgM,aAAa,GAAG;UAAEvD;QAAS,CAAC;QAC5BwD,cAAc,GAAG;UAAExD,QAAQ;UAAEN,YAAY;UAAEkD;QAAS,CAAC;MACvD;MACA,IAAI;QACF,IAAI,CAAC9X,MAAM,EAAE;UACX,MAAM,IAAIQ,KAAK,CAAC,8BAA8B,CAAC;QACjD;QACA,IAAI,UAAU,IAAIkY,cAAc,EAAE;UAChC,MAAMd,MAAM,CAAC,GAAG5X,MAAM,CAACD,IAAI,SAAS,EAAE;YACpCvB,OAAO,EAAE;cAAE,cAAc,EAAE;YAAmB,CAAC;YAC/CkD,MAAM,EAAE,MAAM;YACdC,IAAI,EAAEwG,IAAI,CAACC,SAAS,CAACsQ,cAAc;UACrC,CAAC,CAAC;QACJ;QACA,MAAMd,MAAM,CAAC,GAAG5X,MAAM,CAACD,IAAI,QAAQ,EAAE;UACnCvB,OAAO,EAAE;YAAE,cAAc,EAAE;UAAmB,CAAC;UAC/CkD,MAAM,EAAE,MAAM;UACdC,IAAI,EAAEwG,IAAI,CAACC,SAAS,CAACqQ,aAAa;QACpC,CAAC,CAAC;MACJ,CAAC,CAAC,OAAO5Z,CAAC,EAAE;QACV4G,OAAO,CAACgC,IAAI,CACV,2FACF,CAAC;MACH;IACF;IACA,MAAMkR,iBAAiB,GAAG,MAAOC,OAAO,IAAK;MAC3C,MAAM,IAAI,CAACC,iBAAiB,CAACD,OAAO,CAAC;IACvC,CAAC;IACD,eAAeE,oBAAoBA,CAACC,aAAa,EAAE;MACjD,IAAI,CAAC/Y,MAAM,EACT;MACF,IAAIgZ,SAAS,GAAGD,aAAa,CAACC,SAAS;MACvChZ,MAAM,CAACyE,UAAU,GAAG,CAClB,GAAGzE,MAAM,CAACyE,UAAU,CAACiF,MAAM,CAAE7E,CAAC,IAAKA,CAAC,CAACoU,KAAK,CAACC,WAAW,KAAKF,SAAS,CAAC,EACrE,GAAGD,aAAa,CAACtU,UAAU,CAC5B;MACDzE,MAAM,CAACS,YAAY,GAAG,CACpB,GAAGT,MAAM,CAACS,YAAY,CAACiJ,MAAM,CAAEyP,CAAC,IAAKA,CAAC,CAACD,WAAW,KAAKF,SAAS,CAAC,EACjE,GAAGD,aAAa,CAACtY,YAAY,CAC9B;MACD,MAAM2Y,SAAS,GAAGpZ,MAAM,CAACyE,UAAU,CAACsD,IAAI,CAAElD,CAAC,IAAKA,CAAC,CAACC,IAAI,KAAK,OAAO,CAAC;MACnE,MAAMuU,UAAU,GAAGrZ,MAAM,CAACS,YAAY,CAACsH,IAAI,CACxCoR,CAAC,IAAKA,CAAC,CAACG,OAAO,CAACvR,IAAI,CAAEwR,CAAC,IAAKA,CAAC,CAAC,CAAC,CAAC,KAAK,QAAQ,CAChD,CAAC;MACDvZ,MAAM,CAACwZ,iBAAiB,GAAGJ,SAAS,IAAIC,UAAU;MAClD,MAAMV,iBAAiB,CAAC3Y,MAAM,CAAC;MAC/BmX,UAAU,CAAC;QACTrS,IAAI,EAAE,QAAQ;QACdc,IAAI,EAAEmT,aAAa;QACnB1Z,QAAQ,EAAE4Y,SAAS;QACnBH;MACF,CAAC,CAAC;IACJ;IACA,IAAI,CAACnK,WAAW,CAAC3N,MAAM,CAACD,IAAI,EAAE2H,aAAa,EAAEJ,aAAa,CAAC,CAAC0C,IAAI,CAC9D,MAAOyP,QAAQ,IAAK;MAClB,IAAI7U,GAAG;MACP,IAAI8U,UAAU,GAAGxM,cAAc,CAC7BuM,QAAQ,EACRrM,UAAU,EACVpN,MAAM,CAACyE,UAAU,EACjB,OAAO,EACP,IACF,CAAC;MACDyT,OAAO,GAAG;QACRtS,IAAI,EAAE8T,UAAU,IAAI,EAAE;QACtB1C,UAAU;QACVc,QAAQ;QACRb;MACF,CAAC;MACD,IAAIjL,UAAU,CAAC8L,QAAQ,EAAE9X,MAAM,CAAC,EAAE;QAChCmX,UAAU,CAAC;UACTrS,IAAI,EAAE,QAAQ;UACdzF,QAAQ,EAAE4Y,SAAS;UACnB3R,KAAK,EAAE,SAAS;UAChBD,KAAK,EAAE,KAAK;UACZyR,QAAQ;UACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;QACjC,CAAC,CAAC;QACFX,UAAU,CACR,GAAG7X,MAAM,CAACD,IAAI,OAAOkY,SAAS,CAACha,UAAU,CAAC,GAAG,CAAC,GAAGga,SAAS,GAAG,IAAIA,SAAS,EAAE,GAAGG,UAAU,GAAG,GAAG,GAAGA,UAAU,GAAG,EAAE,EAAE,EACnH;UACE,GAAGF,OAAO;UACVtD;QACF,CACF,CAAC,CAAC5K,IAAI,CAAC,CAAC,CAAChD,MAAM,EAAE2S,WAAW,CAAC,KAAK;UAChC,MAAMpC,KAAK,GAAGvQ,MAAM,CAACpB,IAAI;UACzB,IAAI+T,WAAW,IAAI,GAAG,EAAE;YACtBxC,UAAU,CAAC;cACTrS,IAAI,EAAE,MAAM;cACZzF,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRlS,IAAI,EAAEsH,cAAc,CAClBqK,KAAK,EACLnK,UAAU,EACVpN,MAAM,CAACyE,UAAU,EACjB,QAAQ,EACRlF,OAAO,CAAC8N,eACV,CAAC;cACDkL,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChCxB,UAAU;cACVC;YACF,CAAC,CAAC;YACF,IAAIjQ,MAAM,CAAC+R,aAAa,EAAE;cACxBD,oBAAoB,CAAC9R,MAAM,CAAC+R,aAAa,CAAC;YAC5C;YACA5B,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdzF,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRxR,KAAK,EAAE,UAAU;cACjBO,GAAG,EAAEG,MAAM,CAACC,gBAAgB;cAC5BZ,KAAK,EAAE,KAAK;cACZkS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;YACjC,CAAC,CAAC;UACJ,CAAC,MAAM;YACLrB,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdwB,KAAK,EAAE,OAAO;cACdjH,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACR1W,OAAO,EAAE4F,MAAM,CAACtB,KAAK;cACrBW,KAAK,EAAE,KAAK;cACZkS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;YACjC,CAAC,CAAC;UACJ;QACF,CAAC,CAAC,CAACzB,KAAK,CAAElY,CAAC,IAAK;UACdsY,UAAU,CAAC;YACTrS,IAAI,EAAE,QAAQ;YACdwB,KAAK,EAAE,OAAO;YACdlF,OAAO,EAAEvC,CAAC,CAACuC,OAAO;YAClB/B,QAAQ,EAAE4Y,SAAS;YACnBH,QAAQ;YACRzR,KAAK,EAAE,KAAK;YACZkS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;UACjC,CAAC,CAAC;QACJ,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI3W,QAAQ,IAAI,IAAI,EAAE;QAC3B,MAAM;UAAEI,WAAW;UAAEnB;QAAK,CAAC,GAAG,MAAMC,gBAAgB,CAClDC,aAAa,EACbxB,QACF,CAAC;QACD2X,UAAU,CAAC;UACTrS,IAAI,EAAE,QAAQ;UACdwB,KAAK,EAAE,SAAS;UAChBD,KAAK,EAAE,IAAI;UACXhH,QAAQ,EAAE4Y,SAAS;UACnBH,QAAQ;UACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;QACjC,CAAC,CAAC;QACF,IAAIlQ,GAAG,GAAG,IAAIvG,GAAG,CACf,GAAGE,WAAW,MAAMpE,YAAY,CAC9BiD,IAAI,EACJd,MAAM,CAACF,IAAI,EACX,IACF,CAAC,cAAcsY,UAAU,GAAG,GAAG,GAAGA,UAAU,GAAG,EAAE,EACnD,CAAC;QACD,IAAI,IAAI,CAACzZ,GAAG,EAAE;UACZ2J,GAAG,CAACuM,YAAY,CAACtZ,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACoD,GAAG,CAAC;QAC1C;QACAqZ,SAAS,GAAG,IAAI4B,SAAS,CAACtR,GAAG,CAAC;QAC9B0P,SAAS,CAAC6B,OAAO,GAAIC,GAAG,IAAK;UAC3B,IAAI,CAACA,GAAG,CAACC,QAAQ,EAAE;YACjB5C,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdwB,KAAK,EAAE,OAAO;cACd0T,MAAM,EAAE,IAAI;cACZ5Y,OAAO,EAAEnE,qBAAqB;cAC9BoJ,KAAK,EAAE,IAAI;cACXhH,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;YACjC,CAAC,CAAC;UACJ;QACF,CAAC;QACDR,SAAS,CAACxL,SAAS,GAAG,UAASiH,KAAK,EAAE;UACpC,MAAMqB,KAAK,GAAG3M,IAAI,CAAC4M,KAAK,CAACtB,KAAK,CAAC7N,IAAI,CAAC;UACpC,MAAM;YAAEd,IAAI;YAAExE,MAAM;YAAEsF,IAAI,EAAE2R;UAAM,CAAC,GAAGpR,cAAc,CAClD2O,KAAK,EACL1O,WAAW,CAAC0R,QAAQ,CACtB,CAAC;UACD,IAAIhT,IAAI,KAAK,QAAQ,IAAIxE,MAAM,IAAI,CAAC6X,QAAQ,EAAE;YAC5ChB,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdzF,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChC,GAAGlY;YACL,CAAC,CAAC;YACF,IAAIA,MAAM,CAACgG,KAAK,KAAK,OAAO,EAAE;cAC5B0R,SAAS,CAACvL,KAAK,CAAC,CAAC;YACnB;UACF,CAAC,MAAM,IAAI3H,IAAI,KAAK,MAAM,EAAE;YAC1BkT,SAAS,CAACiC,IAAI,CAAC9R,IAAI,CAACC,SAAS,CAAC;cAAE0P,QAAQ;cAAElD;YAAa,CAAC,CAAC,CAAC;YAC1D;UACF,CAAC,MAAM,IAAI9P,IAAI,KAAK,MAAM,EAAE;YAC1BkT,SAAS,CAACiC,IAAI,CAAC9R,IAAI,CAACC,SAAS,CAAC;cAAE,GAAG8P,OAAO;cAAEtD;YAAa,CAAC,CAAC,CAAC;UAC9D,CAAC,MAAM,IAAI9P,IAAI,KAAK,UAAU,EAAE;YAC9BqT,QAAQ,GAAG7X,MAAM;UACnB,CAAC,MAAM,IAAIwE,IAAI,KAAK,KAAK,EAAE;YACzBqS,UAAU,CAAC;cACTrS,IAAI,EAAE,KAAK;cACXoV,GAAG,EAAE3C,KAAK,CAAC2C,GAAG;cACdC,KAAK,EAAE5C,KAAK,CAAC4C,KAAK;cAClB9a,QAAQ,EAAE4Y,SAAS;cACnB9Q,QAAQ,EAAEoQ,KAAK,CAACpQ,QAAQ;cACxBD,OAAO,EAAEqQ,KAAK,CAACrQ,OAAO;cACtB4Q;YACF,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIhT,IAAI,KAAK,YAAY,EAAE;YAChCqS,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChC,GAAGlY,MAAM;cACTgG,KAAK,EAAEhG,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACgG,KAAK;cAC7CD,KAAK,EAAE,IAAI;cACXhH,QAAQ,EAAE4Y,SAAS;cACnBH;YACF,CAAC,CAAC;UACJ;UACA,IAAIP,KAAK,EAAE;YACTJ,UAAU,CAAC;cACTrS,IAAI,EAAE,MAAM;cACZyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChC5S,IAAI,EAAEsH,cAAc,CAClBqK,KAAK,CAAC3R,IAAI,EACVwH,UAAU,EACVpN,MAAM,CAACyE,UAAU,EACjB,QAAQ,EACRlF,OAAO,CAAC8N,eACV,CAAC;cACDhO,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRd,UAAU;cACVC;YACF,CAAC,CAAC;YACF,IAAIkB,QAAQ,EAAE;cACZhB,UAAU,CAAC;gBACTrS,IAAI,EAAE,QAAQ;gBACdyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;gBAChC,GAAGL,QAAQ;gBACX7R,KAAK,EAAEhG,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACgG,KAAK;gBAC7CD,KAAK,EAAE,IAAI;gBACXhH,QAAQ,EAAE4Y,SAAS;gBACnBH;cACF,CAAC,CAAC;cACFE,SAAS,CAACvL,KAAK,CAAC,CAAC;YACnB;UACF;QACF,CAAC;QACD,IAAIzQ,OAAO,CAACgE,MAAM,CAACkI,OAAO,IAAI,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,EAAE;UACjD0O,gBAAgB,CACd,MAAM,EACN,MAAMoB,SAAS,CAACiC,IAAI,CAAC9R,IAAI,CAACC,SAAS,CAAC;YAAEgS,IAAI,EAAExF;UAAa,CAAC,CAAC,CAC7D,CAAC;QACH;MACF,CAAC,MAAM,IAAI/S,QAAQ,IAAI,KAAK,EAAE;QAC5BsV,UAAU,CAAC;UACTrS,IAAI,EAAE,QAAQ;UACdwB,KAAK,EAAE,SAAS;UAChBD,KAAK,EAAE,IAAI;UACXhH,QAAQ,EAAE4Y,SAAS;UACnBH,QAAQ;UACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;QACjC,CAAC,CAAC;QACF,IAAI9D,MAAM,GAAG,IAAIC,eAAe,CAAC;UAC/BmD,QAAQ,EAAEA,QAAQ,CAAC5U,QAAQ,CAAC,CAAC;UAC7B0R;QACF,CAAC,CAAC,CAAC1R,QAAQ,CAAC,CAAC;QACb,IAAIoF,GAAG,GAAG,IAAIvG,GAAG,CACf,GAAG/B,MAAM,CAACD,IAAI,eAAeqY,UAAU,GAAGA,UAAU,GAAG,GAAG,GAAG,EAAE,GAAG1D,MAAM,EAC1E,CAAC;QACD,IAAI,IAAI,CAAC/V,GAAG,EAAE;UACZ2J,GAAG,CAACuM,YAAY,CAACtZ,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACoD,GAAG,CAAC;QAC1C;QACA8V,OAAO,GAAG,IAAI,CAACX,MAAM,CAACxL,GAAG,CAAC;QAC1B,IAAI,CAACmM,OAAO,EAAE;UACZ,OAAO3K,OAAO,CAACoF,MAAM,CACnB,IAAI1O,KAAK,CAAC,kCAAkC,GAAG8H,GAAG,CAACpF,QAAQ,CAAC,CAAC,CAC/D,CAAC;QACH;QACAuR,OAAO,CAACjI,SAAS,GAAG,gBAAeiH,KAAK,EAAE;UACxC,MAAMqB,KAAK,GAAG3M,IAAI,CAAC4M,KAAK,CAACtB,KAAK,CAAC7N,IAAI,CAAC;UACpC,MAAM;YAAEd,IAAI;YAAExE,MAAM;YAAEsF,IAAI,EAAE2R;UAAM,CAAC,GAAGpR,cAAc,CAClD2O,KAAK,EACL1O,WAAW,CAAC0R,QAAQ,CACtB,CAAC;UACD,IAAIhT,IAAI,KAAK,QAAQ,IAAIxE,MAAM,IAAI,CAAC6X,QAAQ,EAAE;YAC5ChB,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdzF,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChC,GAAGlY;YACL,CAAC,CAAC;YACF,IAAIA,MAAM,CAACgG,KAAK,KAAK,OAAO,EAAE;cAC5BmO,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAChI,KAAK,CAAC,CAAC;cAC1CA,KAAK,CAAC,CAAC;YACT;UACF,CAAC,MAAM,IAAI3H,IAAI,KAAK,MAAM,EAAE;YAC1BoQ,QAAQ,GAAGJ,KAAK,CAACI,QAAQ;YACzB,IAAI,CAAC1J,CAAC,EAAE6O,OAAO,CAAC,GAAG,MAAMxC,UAAU,CAAC,GAAG7X,MAAM,CAACD,IAAI,aAAa,EAAE;cAC/D,GAAGmY,OAAO;cACVtD,YAAY;cACZM;YACF,CAAC,CAAC;YACF,IAAImF,OAAO,KAAK,GAAG,EAAE;cACnBlD,UAAU,CAAC;gBACTrS,IAAI,EAAE,QAAQ;gBACdwB,KAAK,EAAE,OAAO;gBACdlF,OAAO,EAAEnE,qBAAqB;gBAC9BoJ,KAAK,EAAE,IAAI;gBACXhH,QAAQ,EAAE4Y,SAAS;gBACnBH,QAAQ;gBACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;cACjC,CAAC,CAAC;cACF/D,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAChI,KAAK,CAAC,CAAC;cAC1CA,KAAK,CAAC,CAAC;YACT;UACF,CAAC,MAAM,IAAI3H,IAAI,KAAK,UAAU,EAAE;YAC9BqT,QAAQ,GAAG7X,MAAM;UACnB,CAAC,MAAM,IAAIwE,IAAI,KAAK,KAAK,EAAE;YACzBqS,UAAU,CAAC;cACTrS,IAAI,EAAE,KAAK;cACXoV,GAAG,EAAE3C,KAAK,CAAC2C,GAAG;cACdC,KAAK,EAAE5C,KAAK,CAAC4C,KAAK;cAClB9a,QAAQ,EAAE4Y,SAAS;cACnB9Q,QAAQ,EAAEoQ,KAAK,CAACpQ,QAAQ;cACxBD,OAAO,EAAEqQ,KAAK,CAACrQ,OAAO;cACtB4Q;YACF,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIhT,IAAI,KAAK,YAAY,EAAE;YAChCqS,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChC,GAAGlY,MAAM;cACTgG,KAAK,EAAEhG,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACgG,KAAK;cAC7CD,KAAK,EAAE,IAAI;cACXhH,QAAQ,EAAE4Y,SAAS;cACnBH;YACF,CAAC,CAAC;UACJ;UACA,IAAIP,KAAK,EAAE;YACTJ,UAAU,CAAC;cACTrS,IAAI,EAAE,MAAM;cACZyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;cAChC5S,IAAI,EAAEsH,cAAc,CAClBqK,KAAK,CAAC3R,IAAI,EACVwH,UAAU,EACVpN,MAAM,CAACyE,UAAU,EACjB,QAAQ,EACRlF,OAAO,CAAC8N,eACV,CAAC;cACDhO,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRd,UAAU;cACVC;YACF,CAAC,CAAC;YACF,IAAIkB,QAAQ,EAAE;cACZhB,UAAU,CAAC;gBACTrS,IAAI,EAAE,QAAQ;gBACdyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;gBAChC,GAAGL,QAAQ;gBACX7R,KAAK,EAAEhG,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACgG,KAAK;gBAC7CD,KAAK,EAAE,IAAI;gBACXhH,QAAQ,EAAE4Y,SAAS;gBACnBH;cACF,CAAC,CAAC;cACFrD,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAChI,KAAK,CAAC,CAAC;cAC1CA,KAAK,CAAC,CAAC;YACT;UACF;QACF,CAAC;MACH,CAAC,MAAM,IAAI5K,QAAQ,IAAI,QAAQ,IAAIA,QAAQ,IAAI,QAAQ,IAAIA,QAAQ,IAAI,UAAU,IAAIA,QAAQ,IAAI,QAAQ,EAAE;QACzGsV,UAAU,CAAC;UACTrS,IAAI,EAAE,QAAQ;UACdwB,KAAK,EAAE,SAAS;UAChBD,KAAK,EAAE,IAAI;UACXhH,QAAQ,EAAE4Y,SAAS;UACnBH,QAAQ;UACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;QACjC,CAAC,CAAC;QACF,IAAI8B,QAAQ,GAAG,EAAE;QACjB,IAAI,OAAO7a,MAAM,KAAK,WAAW,IAAI,OAAO6V,QAAQ,KAAK,WAAW,EAAE;UACpEgF,QAAQ,GAAG,CAAC1V,GAAG,GAAGnF,MAAM,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACE,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGiF,GAAG,CAAC0V,QAAQ;QAC9F;QACA,IAAIC,QAAQ,GAAG,6BAA6B;QAC5C,MAAM3a,MAAM,GAAG0a,QAAQ,CAACxJ,QAAQ,CAAC,OAAO,CAAC,GAAG,gBAAgBwJ,QAAQ,CAACle,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAIme,QAAQ,EAAE,GAAG,wBAAwB;QAC3H,MAAMC,SAAS,GAAG,OAAO/a,MAAM,KAAK,WAAW,IAAI,OAAO6V,QAAQ,KAAK,WAAW,IAAI7V,MAAM,CAACiN,MAAM,IAAIjN,MAAM;QAC7G,MAAMgb,gBAAgB,GAAGrN,UAAU,CAACsN,OAAO,IAAI1a,MAAM,CAAC8C,QAAQ;QAC9D,MAAM6X,oBAAoB,GAAGH,SAAS,IAAIC,gBAAgB,GAAGtO,YAAY,CAAC,iBAAiB,EAAEvM,MAAM,CAAC,GAAGkK,OAAO,CAAC0E,OAAO,CAAC,IAAI,CAAC;QAC5H,MAAMoM,iBAAiB,GAAGD,oBAAoB,CAAC3Q,IAAI,CAAExL,OAAO,IAAK;UAC/D,OAAOqZ,UAAU,CACf,GAAG7X,MAAM,CAACD,IAAI,eAAeqY,UAAU,EAAE,EACzC;YACE,GAAGF,OAAO;YACVtD;UACF,CAAC,EACDpW,OACF,CAAC;QACH,CAAC,CAAC;QACFoc,iBAAiB,CAAC5Q,IAAI,CAAC,OAAO,CAAC5J,QAAQ,EAAEE,MAAM,CAAC,KAAK;UACnD,IAAIA,MAAM,KAAK,GAAG,EAAE;YAClB6W,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdwB,KAAK,EAAE,OAAO;cACdlF,OAAO,EAAEpE,cAAc;cACvBqJ,KAAK,EAAE,IAAI;cACXhH,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;YACjC,CAAC,CAAC;UACJ,CAAC,MAAM,IAAIlY,MAAM,KAAK,GAAG,EAAE;YACzB6W,UAAU,CAAC;cACTrS,IAAI,EAAE,QAAQ;cACdwB,KAAK,EAAE,OAAO;cACdlF,OAAO,EAAEnE,qBAAqB;cAC9BoJ,KAAK,EAAE,IAAI;cACXhH,QAAQ,EAAE4Y,SAAS;cACnBH,QAAQ;cACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;YACjC,CAAC,CAAC;UACJ,CAAC,MAAM;YACLtD,QAAQ,GAAG9U,QAAQ,CAAC8U,QAAQ;YAC5B,IAAI2F,QAAQ,GAAG,eAAAA,CAAe/F,KAAK,EAAE;cACnC,IAAI;gBACF,MAAM;kBAAEhQ,IAAI;kBAAExE,MAAM,EAAE+Z,OAAO;kBAAEzU,IAAI,EAAE2R;gBAAM,CAAC,GAAGpR,cAAc,CAC3D2O,KAAK,EACL1O,WAAW,CAAC0R,QAAQ,CACtB,CAAC;gBACD,IAAIhT,IAAI,IAAI,WAAW,EAAE;kBACvB;gBACF;gBACA,IAAIA,IAAI,KAAK,QAAQ,IAAIuV,OAAO,IAAI,CAAClC,QAAQ,EAAE;kBAC7ChB,UAAU,CAAC;oBACTrS,IAAI,EAAE,QAAQ;oBACdzF,QAAQ,EAAE4Y,SAAS;oBACnBH,QAAQ;oBACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;oBAChC,GAAG6B;kBACL,CAAC,CAAC;gBACJ,CAAC,MAAM,IAAIvV,IAAI,KAAK,UAAU,EAAE;kBAC9BqT,QAAQ,GAAGkC,OAAO;gBACpB,CAAC,MAAM,IAAIvV,IAAI,IAAI,kBAAkB,EAAE;kBACrCW,OAAO,CAACC,KAAK,CAAC,kBAAkB,EAAE2U,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACjZ,OAAO,CAAC;kBAC7E+V,UAAU,CAAC;oBACTrS,IAAI,EAAE,QAAQ;oBACdwB,KAAK,EAAE,OAAO;oBACdlF,OAAO,EAAE,CAACiZ,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACjZ,OAAO,KAAK,+BAA+B;oBACxFiF,KAAK,EAAE,IAAI;oBACXhH,QAAQ,EAAE4Y,SAAS;oBACnBH,QAAQ;oBACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;kBACjC,CAAC,CAAC;gBACJ,CAAC,MAAM,IAAI1T,IAAI,KAAK,KAAK,EAAE;kBACzBqS,UAAU,CAAC;oBACTrS,IAAI,EAAE,KAAK;oBACXoV,GAAG,EAAE3C,KAAK,CAAC2C,GAAG;oBACdC,KAAK,EAAE5C,KAAK,CAAC4C,KAAK;oBAClB9a,QAAQ,EAAE4Y,SAAS;oBACnB9Q,QAAQ,EAAEoQ,KAAK,CAACpQ,QAAQ;oBACxBD,OAAO,EAAEqQ,KAAK,CAACrQ,OAAO;oBACtB4Q;kBACF,CAAC,CAAC;kBACF;gBACF,CAAC,MAAM,IAAIhT,IAAI,KAAK,YAAY,EAAE;kBAChCqS,UAAU,CAAC;oBACTrS,IAAI,EAAE,QAAQ;oBACdyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;oBAChC,GAAG6B,OAAO;oBACV/T,KAAK,EAAE+T,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC/T,KAAK;oBAC/CD,KAAK,EAAE,IAAI;oBACXhH,QAAQ,EAAE4Y,SAAS;oBACnBH;kBACF,CAAC,CAAC;kBACF,IAAIP,KAAK,IAAI,CAAC,QAAQ,EAAE,UAAU,EAAE,QAAQ,CAAC,CAACzG,QAAQ,CAACjP,QAAQ,CAAC,EAAE;oBAChE4T,iBAAiB,CAACC,oBAAoB,EAAER,QAAQ,EAAEqC,KAAK,CAAC;kBAC1D;gBACF;gBACA,IAAIA,KAAK,EAAE;kBACTJ,UAAU,CAAC;oBACTrS,IAAI,EAAE,MAAM;oBACZyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;oBAChC5S,IAAI,EAAEsH,cAAc,CAClBqK,KAAK,CAAC3R,IAAI,EACVwH,UAAU,EACVpN,MAAM,CAACyE,UAAU,EACjB,QAAQ,EACRlF,OAAO,CAAC8N,eACV,CAAC;oBACDhO,QAAQ,EAAE4Y,SAAS;oBACnBH;kBACF,CAAC,CAAC;kBACF,IAAIP,KAAK,CAACwB,aAAa,EAAE;oBACvB,MAAMD,oBAAoB,CAACvB,KAAK,CAACwB,aAAa,CAAC;kBACjD;kBACA,IAAIZ,QAAQ,EAAE;oBACZhB,UAAU,CAAC;sBACTrS,IAAI,EAAE,QAAQ;sBACdyT,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC,CAAC;sBAChC,GAAGL,QAAQ;sBACX7R,KAAK,EAAE+T,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC/T,KAAK;sBAC/CD,KAAK,EAAE,IAAI;sBACXhH,QAAQ,EAAE4Y,SAAS;sBACnBH;oBACF,CAAC,CAAC;oBACFrL,KAAK,CAAC,CAAC;kBACT;gBACF;gBACA,IAAI,CAAC4N,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC/T,KAAK,MAAM,UAAU,IAAI,CAAC+T,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAAC/T,KAAK,MAAM,OAAO,EAAE;kBACvH,IAAI6N,eAAe,CAACe,QAAQ,CAAC,EAAE;oBAC7B,OAAOf,eAAe,CAACe,QAAQ,CAAC;kBAClC;kBACA,IAAIA,QAAQ,IAAIQ,oBAAoB,EAAE;oBACpC,OAAOA,oBAAoB,CAACR,QAAQ,CAAC;kBACvC;gBACF;cACF,CAAC,CAAC,OAAOrW,CAAC,EAAE;gBACV4G,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAE7G,CAAC,CAAC;gBAC/CsY,UAAU,CAAC;kBACTrS,IAAI,EAAE,QAAQ;kBACdwB,KAAK,EAAE,OAAO;kBACdlF,OAAO,EAAE,+BAA+B;kBACxCiF,KAAK,EAAE,IAAI;kBACXhH,QAAQ,EAAE4Y,SAAS;kBACnBH,QAAQ;kBACRS,IAAI,EAAE,eAAgB,IAAIC,IAAI,CAAC;gBACjC,CAAC,CAAC;gBACF,IAAI,CAAC,QAAQ,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC1H,QAAQ,CAACjP,QAAQ,CAAC,EAAE;kBACvDmT,YAAY,CAACV,aAAa,EAAEC,IAAI,CAACU,gBAAgB,CAAC;kBAClDX,aAAa,CAACE,IAAI,GAAG,KAAK;kBAC1B/H,KAAK,CAAC,CAAC;gBACT;cACF;YACF,CAAC;YACD,IAAIyI,QAAQ,IAAIb,uBAAuB,EAAE;cACvCA,uBAAuB,CAACa,QAAQ,CAAC,CAACjW,OAAO,CACtCpE,GAAG,IAAKggB,QAAQ,CAAChgB,GAAG,CACvB,CAAC;cACD,OAAOwZ,uBAAuB,CAACa,QAAQ,CAAC;YAC1C;YACAf,eAAe,CAACe,QAAQ,CAAC,GAAG2F,QAAQ;YACpCzG,eAAe,CAAC9Y,GAAG,CAAC4Z,QAAQ,CAAC;YAC7B,IAAI,CAACZ,aAAa,CAACE,IAAI,EAAE;cACvB,MAAM,IAAI,CAACN,WAAW,CAAC,CAAC;YAC1B;UACF;QACF,CAAC,CAAC;MACJ;IACF,CACF,CAAC;IACD,IAAIN,IAAI,GAAG,KAAK;IAChB,MAAM4D,MAAM,GAAG,EAAE;IACjB,MAAMF,SAAS,GAAG,EAAE;IACpB,MAAMwD,QAAQ,GAAG;MACf,CAACC,MAAM,CAACC,aAAa,GAAG,MAAMF,QAAQ;MACtCnD,IAAI;MACJsD,KAAK,EAAE,MAAO3gB,KAAK,IAAK;QACtBmd,UAAU,CAACnd,KAAK,CAAC;QACjB,OAAOqd,IAAI,CAAC,CAAC;MACf,CAAC;MACDuD,MAAM,EAAE,MAAAA,CAAA,KAAY;QAClBzO,KAAK,CAAC,CAAC;QACP,OAAOkL,IAAI,CAAC,CAAC;MACf,CAAC;MACDrT;IACF,CAAC;IACD,OAAOwW,QAAQ;EACjB,CAAC,CAAC,OAAOpV,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,uCAAuC,EAAEA,KAAK,CAAC;IAC7D,MAAMA,KAAK;EACb;AACF;AACA,SAASgS,eAAeA,CAAChS,KAAK,EAAE;EAC9B,OAAO;IACLsE,IAAI,EAAEA,CAACwE,OAAO,EAAEU,MAAM,KAAKA,MAAM,CAACxJ,KAAK;EACzC,CAAC;AACH;AACA,SAASqS,iBAAiBA,CAAC3U,QAAQ,EAAE/D,QAAQ,EAAEgE,OAAO,EAAErD,MAAM,EAAE;EAC9D,IAAI8X,QAAQ;EACZ,IAAIxQ,aAAa;EACjB,IAAI8F,UAAU;EACd,IAAI,OAAO/N,QAAQ,KAAK,QAAQ,EAAE;IAChCyY,QAAQ,GAAGzY,QAAQ;IACnBiI,aAAa,GAAGlE,QAAQ,CAACI,iBAAiB,CAACsU,QAAQ,CAAC;IACpD1K,UAAU,GAAGpN,MAAM,CAACS,YAAY,CAACyD,IAAI,CAAExD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAIE,QAAQ,CAAC;EACpE,CAAC,MAAM;IACL,MAAM4P,gBAAgB,GAAG5P,QAAQ,CAACuD,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IACpDkV,QAAQ,GAAGzU,OAAO,CAAC4L,gBAAgB,CAAC;IACpC3H,aAAa,GAAGlE,QAAQ,CAACG,eAAe,CAAClE,QAAQ,CAACmD,IAAI,CAAC,CAAC,CAAC;IACzD4K,UAAU,GAAGpN,MAAM,CAACS,YAAY,CAACyD,IAAI,CAClCxD,GAAG,IAAKA,GAAG,CAACvB,EAAE,IAAIkE,OAAO,CAAC4L,gBAAgB,CAC7C,CAAC;EACH;EACA,IAAI,OAAO6I,QAAQ,KAAK,QAAQ,EAAE;IAChC,MAAM,IAAItX,KAAK,CACb,2EACF,CAAC;EACH;EACA,OAAO;IAAEsX,QAAQ;IAAExQ,aAAa;IAAE8F;EAAW,CAAC;AAChD;AACA,MAAMgE,MAAM,CAAC;EACX9G,WAAWA,CAACtJ,aAAa,EAAEzB,OAAO,GAAG;IAAE4T,MAAM,EAAE,CAAC,MAAM;EAAE,CAAC,EAAE;IACzDzY,aAAa,CAAC,IAAI,EAAE,eAAe,CAAC;IACpCA,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC;IAC9BA,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC;IAC7BA,aAAa,CAAC,IAAI,EAAE,UAAU,CAAC;IAC/BA,aAAa,CAAC,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;IAClCA,aAAa,CAAC,IAAI,EAAE,cAAc,EAAEygB,IAAI,CAACC,MAAM,CAAC,CAAC,CAAClY,QAAQ,CAAC,EAAE,CAAC,CAAC8P,SAAS,CAAC,CAAC,CAAC,CAAC;IAC5EtY,aAAa,CAAC,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC;IACjCA,aAAa,CAAC,IAAI,EAAE,aAAa,EAAE,CAAC,CAAC,CAAC;IACtCA,aAAa,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC;IACpC;IACAA,aAAa,CAAC,IAAI,EAAE,eAAe,EAAE;MAAE8Z,IAAI,EAAE;IAAM,CAAC,CAAC;IACrD9Z,aAAa,CAAC,IAAI,EAAE,yBAAyB,EAAE,CAAC,CAAC,CAAC;IAClDA,aAAa,CAAC,IAAI,EAAE,sBAAsB,EAAE,CAAC,CAAC,CAAC;IAC/CA,aAAa,CAAC,IAAI,EAAE,iBAAiB,EAAE,CAAC,CAAC,CAAC;IAC1CA,aAAa,CAAC,IAAI,EAAE,iBAAiB,EAAE,eAAgB,IAAI2gB,GAAG,CAAC,CAAC,CAAC;IACjE3gB,aAAa,CAAC,IAAI,EAAE,iBAAiB,EAAE,IAAI,CAAC;IAC5CA,aAAa,CAAC,IAAI,EAAE,kBAAkB,EAAE,IAAI,CAAC;IAC7CA,aAAa,CAAC,IAAI,EAAE,iBAAiB,EAAE,IAAI,CAAC;IAC5CA,aAAa,CAAC,IAAI,EAAE,UAAU,CAAC;IAC/BA,aAAa,CAAC,IAAI,EAAE,cAAc,CAAC;IACnCA,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC;IAC7BA,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC;IAClCA,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC;IAChCA,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC;IAC7BA,aAAa,CAAC,IAAI,EAAE,SAAS,CAAC;IAC9BA,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC;IAClCA,aAAa,CAAC,IAAI,EAAE,gBAAgB,CAAC;IACrCA,aAAa,CAAC,IAAI,EAAE,iBAAiB,CAAC;IACtC,IAAI,CAACsG,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACzB,OAAO,CAAC4T,MAAM,EAAE;MACnB5T,OAAO,CAAC4T,MAAM,GAAG,CAAC,MAAM,CAAC;IAC3B;IACA,IAAI,CAAC5T,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACyI,QAAQ,GAAGA,QAAQ,CAACsT,IAAI,CAAC,IAAI,CAAC;IACnC,IAAI,CAAC7S,YAAY,GAAGA,YAAY,CAAC6S,IAAI,CAAC,IAAI,CAAC;IAC3C,IAAI,CAAC3N,WAAW,GAAGA,WAAW,CAAC2N,IAAI,CAAC,IAAI,CAAC;IACzC,IAAI,CAAC1M,SAAS,GAAGA,SAAS,CAAC0M,IAAI,CAAC,IAAI,CAAC;IACrC,IAAI,CAAClM,MAAM,GAAGA,MAAM,CAACkM,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAI,CAACxM,OAAO,GAAGA,OAAO,CAACwM,IAAI,CAAC,IAAI,CAAC;IACjC,IAAI,CAACpH,WAAW,GAAGA,WAAW,CAACoH,IAAI,CAAC,IAAI,CAAC;IACzC,IAAI,CAAClc,cAAc,GAAGA,cAAc,CAACkc,IAAI,CAAC,IAAI,CAAC;IAC/C,IAAI,CAAC1a,eAAe,GAAGA,eAAe,CAAC0a,IAAI,CAAC,IAAI,CAAC;IACjD,IAAI,CAAClS,MAAM,GAAGA,MAAM,CAACkS,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAI,CAAC/c,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC+c,IAAI,CAAC,IAAI,CAAC;IAClC,IAAI,CAACC,oBAAoB,GAAG,IAAI,CAACA,oBAAoB,CAACD,IAAI,CAAC,IAAI,CAAC;IAChE,IAAI,CAACxH,MAAM,GAAG,IAAI,CAACA,MAAM,CAACwH,IAAI,CAAC,IAAI,CAAC;EACtC;EACA/c,KAAKA,CAACoG,KAAK,EAAEoP,IAAI,EAAE;IACjB,MAAMvV,OAAO,GAAG,IAAIgd,OAAO,CAAC,CAACzH,IAAI,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,IAAI,CAACvV,OAAO,KAAK,CAAC,CAAC,CAAC;IACzE,IAAI,IAAI,IAAI,IAAI,CAACH,OAAO,EAAE;MACxBG,OAAO,CAACgD,MAAM,CAAC,QAAQ,EAAE,IAAI,CAACnD,OAAO,CAAC;IACxC;IACA,OAAOE,KAAK,CAACoG,KAAK,EAAE;MAAE,GAAGoP,IAAI;MAAEvV;IAAQ,CAAC,CAAC;EAC3C;EACAsV,MAAMA,CAACxL,GAAG,EAAE;IACV,MAAM9J,OAAO,GAAG,IAAIgd,OAAO,CAAC,CAAC;IAC7B,IAAI,IAAI,IAAI,IAAI,CAACnd,OAAO,EAAE;MACxBG,OAAO,CAACgD,MAAM,CAAC,QAAQ,EAAE,IAAI,CAACnD,OAAO,CAAC;IACxC;IACA,IAAI,CAAC4W,gBAAgB,GAAG,IAAIwG,eAAe,CAAC,CAAC;IAC7C,IAAI,CAACC,eAAe,GAAGtF,eAAe,CAAC9N,GAAG,CAACpF,QAAQ,CAAC,CAAC,EAAE;MACrD7C,WAAW,EAAE,SAAS;MACtB7B,OAAO;MACP4U,MAAM,EAAE,IAAI,CAAC6B,gBAAgB,CAAC7B;IAChC,CAAC,CAAC;IACF,OAAO,IAAI,CAACsI,eAAe;EAC7B;EACA,MAAM3H,IAAIA,CAAA,EAAG;IACX,IAAIzU,EAAE;IACN,IAAI,CAAC,OAAOG,MAAM,KAAK,WAAW,IAAI,EAAE,WAAW,IAAIA,MAAM,CAAC,KAAK,CAACkc,MAAM,CAAC/B,SAAS,EAAE;MACpF,MAAMgC,EAAE,GAAG,MAAM,MAAM,CAAC,uBAAuB,CAAC;MAChDD,MAAM,CAAC/B,SAAS,GAAGgC,EAAE,CAAChC,SAAS;IACjC;IACA,IAAI;MACF,IAAI,IAAI,CAACra,OAAO,CAACgB,IAAI,EAAE;QACrB,MAAM,IAAI,CAACK,eAAe,CAAC,CAAC;MAC9B;MACA,MAAM,IAAI,CAACib,eAAe,CAAC,CAAC,CAAC7R,IAAI,CAC/B,CAAC;QAAEhK;MAAO,CAAC,KAAK,IAAI,CAAC6Y,iBAAiB,CAAC7Y,MAAM,CAC/C,CAAC;IACH,CAAC,CAAC,OAAOnB,CAAC,EAAE;MACV,MAAM2B,KAAK,CAAC3B,CAAC,CAAC;IAChB;IACA,IAAI,CAACuE,QAAQ,GAAG,MAAM,IAAI,CAAC4E,QAAQ,CAAC,CAAC;IACrC,IAAI,CAAC3E,OAAO,GAAGvE,gBAAgB,CAAC,CAAC,CAACQ,EAAE,GAAG,IAAI,CAACU,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGV,EAAE,CAACmB,YAAY,KAAK,EAAE,CAAC;EAChG;EACA,MAAMoY,iBAAiBA,CAACiD,OAAO,EAAE;IAC/B,IAAIA,OAAO,EAAE;MACX,IAAI,CAAC9b,MAAM,GAAG8b,OAAO;MACrB,IAAI,IAAI,CAAC9b,MAAM,IAAI,IAAI,CAACA,MAAM,CAACwZ,iBAAiB,EAAE;QAChD,IAAI,IAAI,CAACxZ,MAAM,CAAC8C,QAAQ,IAAI,IAAI,CAACvD,OAAO,CAACC,QAAQ,EAAE;UACjD,IAAI,CAACb,GAAG,GAAG,MAAMT,OAAO,CACtB,IAAI,CAAC8B,MAAM,CAAC8C,QAAQ,EACpB,IAAI,CAACvD,OAAO,CAACC,QAAQ,EACrB,IAAI,CAACnB,OACP,CAAC;QACH;MACF;IACF;IACA,IAAIyd,OAAO,CAAChZ,QAAQ,IAAI,IAAI,CAACvD,OAAO,CAACC,QAAQ,EAAE;MAC7C,IAAI,CAACb,GAAG,GAAG,MAAMT,OAAO,CAAC4d,OAAO,CAAChZ,QAAQ,EAAE,IAAI,CAACvD,OAAO,CAACC,QAAQ,CAAC;IACnE;IACA,IAAI,IAAI,CAACQ,MAAM,IAAI,IAAI,CAACA,MAAM,CAACwZ,iBAAiB,EAAE;MAChD,MAAMuC,aAAa,GAAG,IAAIha,GAAG,CAC3B,GAAG,IAAI,CAAC/B,MAAM,CAACD,IAAI,cAAc,IAAI,CAAC6U,YAAY,EACpD,CAAC;MACD,IAAI,IAAI,CAACjW,GAAG,EAAE;QACZod,aAAa,CAAClH,YAAY,CAACtZ,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACoD,GAAG,CAAC;MACpD;MACA,IAAI,CAAC,IAAI,CAACqd,eAAe,EAAE;QACzB,IAAI,CAACA,eAAe,GAAG,IAAI,CAAClI,MAAM,CAACiI,aAAa,CAAC;MACnD;IACF;EACF;EACA,aAAa1K,OAAOA,CAACrQ,aAAa,EAAEzB,OAAO,GAAG;IAC5C4T,MAAM,EAAE,CAAC,MAAM;EACjB,CAAC,EAAE;IACD,MAAMlF,OAAO,GAAG,IAAI,IAAI,CAACjN,aAAa,EAAEzB,OAAO,CAAC;IAChD,MAAM0O,OAAO,CAAC8F,IAAI,CAAC,CAAC;IACpB,OAAO9F,OAAO;EAChB;EACAxB,KAAKA,CAAA,EAAG;IACNuI,YAAY,CAAC,IAAI,CAACV,aAAa,EAAE,IAAI,CAACW,gBAAgB,CAAC;EACzD;EACA,aAAatE,SAASA,CAAC3P,aAAa,EAAEzB,OAAO,GAAG;IAC9C4T,MAAM,EAAE,CAAC,MAAM;EACjB,CAAC,EAAE;IACD,OAAOxC,SAAS,CAAC3P,aAAa,EAAEzB,OAAO,CAAC;EAC1C;EACA,MAAMsc,eAAeA,CAAA,EAAG;IACtB,MAAM;MAAEhb,aAAa;MAAEC,IAAI;MAAEgC;IAAS,CAAC,GAAG,MAAM/B,gBAAgB,CAC9D,IAAI,CAACC,aAAa,EAClB,IAAI,CAACzB,OAAO,CAACC,QACf,CAAC;IACD,MAAM;MAAE+P;IAAgB,CAAC,GAAG,IAAI,CAAChQ,OAAO;IACxC,IAAIuD,QAAQ,IAAIyM,eAAe,EAAE;MAC/B,MAAMQ,oBAAoB,CAACjN,QAAQ,EAAEyM,eAAe,CAAC;IACvD;IACA,IAAIvP,MAAM;IACV,IAAI;MACFA,MAAM,GAAG,MAAM,IAAI,CAACZ,cAAc,CAAC,GAAGyB,aAAa,KAAKC,IAAI,EAAE,CAAC;MAC/D,IAAI,CAACd,MAAM,EAAE;QACX,MAAM,IAAIQ,KAAK,CAACtD,gBAAgB,CAAC;MACnC;MACA,OAAO,IAAI,CAAC+e,cAAc,CAACjc,MAAM,CAAC;IACpC,CAAC,CAAC,OAAOnB,CAAC,EAAE;MACV,IAAIiE,QAAQ,IAAIyM,eAAe,EAAE;QAC/BD,kBAAkB,CAChBxM,QAAQ,EACRL,aAAa,CAAClG,IAAI,CAACuG,QAAQ,CAAC,GAAG,YAAY,GAAG,WAAW,EACzD,IAAI,CAACyY,oBACP,CAAC;MACH,CAAC,MAAM;QACL,IAAIhM,eAAe,EACjBA,eAAe,CAAC;UACdjP,MAAM,EAAE,OAAO;UACfc,OAAO,EAAE,4BAA4B;UACrCqO,WAAW,EAAE,OAAO;UACpBC,MAAM,EAAE;QACV,CAAC,CAAC;QACJ,MAAMlP,KAAK,CAAC3B,CAAC,CAAC;MAChB;IACF;EACF;EACA,MAAMod,cAAcA,CAACH,OAAO,EAAE;IAC5B,IAAI,CAAC9b,MAAM,GAAG8b,OAAO;IACrB,IAAI,OAAOrc,MAAM,KAAK,WAAW,IAAI,OAAO6V,QAAQ,KAAK,WAAW,EAAE;MACpE,IAAI7V,MAAM,CAACE,QAAQ,CAACkC,QAAQ,KAAK,QAAQ,EAAE;QACzC,IAAI,CAAC7B,MAAM,CAACD,IAAI,GAAG,IAAI,CAACC,MAAM,CAACD,IAAI,CAAC6C,OAAO,CAAC,SAAS,EAAE,UAAU,CAAC;MACpE;IACF;IACA,IAAI,IAAI,CAAC5C,MAAM,CAACkc,aAAa,EAAE;MAC7B,OAAO,IAAI,CAACC,kBAAkB,CAAC,CAAC;IAClC;IACA,IAAI;MACF,IAAI,CAAC/Y,QAAQ,GAAG,MAAM,IAAI,CAAC4E,QAAQ,CAAC,CAAC;IACvC,CAAC,CAAC,OAAOnJ,CAAC,EAAE;MACV4G,OAAO,CAACC,KAAK,CAACtI,kBAAkB,GAAGyB,CAAC,CAACuC,OAAO,CAAC;IAC/C;IACA,OAAO,IAAI,CAAC+a,kBAAkB,CAAC,CAAC;EAClC;EACA,MAAMZ,oBAAoBA,CAACjb,MAAM,EAAE;IACjC,IAAI,CAAC,IAAI,EAAE;MACT,MAAM,IAAIE,KAAK,CAACtD,gBAAgB,CAAC;IACnC;IACA,MAAM;MAAEqS;IAAgB,CAAC,GAAG,IAAI,CAAChQ,OAAO;IACxC,IAAIgQ,eAAe,EACjBA,eAAe,CAACjP,MAAM,CAAC;IACzB,IAAIA,MAAM,CAACA,MAAM,KAAK,SAAS,EAAE;MAC/B,IAAI;QACF,IAAI,CAACN,MAAM,GAAG,MAAM,IAAI,CAAC6b,eAAe,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAI,CAAC7b,MAAM,EAAE;UAChB,MAAM,IAAIQ,KAAK,CAACtD,gBAAgB,CAAC;QACnC;QACA,MAAM4e,OAAO,GAAG,MAAM,IAAI,CAACG,cAAc,CAAC,IAAI,CAACjc,MAAM,CAAC;QACtD,OAAO8b,OAAO;MAChB,CAAC,CAAC,OAAOjd,CAAC,EAAE;QACV,IAAI0Q,eAAe,EAAE;UACnBA,eAAe,CAAC;YACdjP,MAAM,EAAE,OAAO;YACfc,OAAO,EAAE,4BAA4B;YACrCqO,WAAW,EAAE,OAAO;YACpBC,MAAM,EAAE;UACV,CAAC,CAAC;QACJ;QACA,MAAM7Q,CAAC;MACT;IACF;EACF;EACA,MAAMud,gBAAgBA,CAACC,YAAY,EAAEC,OAAO,EAAE1W,IAAI,EAAE;IAClD,IAAItG,EAAE;IACN,IAAI,CAAC,IAAI,CAACU,MAAM,EAAE;MAChB,MAAM,IAAIQ,KAAK,CAACtD,gBAAgB,CAAC;IACnC;IACA,MAAMsB,OAAO,GAAG,CAAC,CAAC;IAClB,MAAM;MAAEgB;IAAS,CAAC,GAAG,IAAI,CAACD,OAAO;IACjC,MAAM;MAAEqV;IAAa,CAAC,GAAG,IAAI;IAC7B,IAAIpV,QAAQ,EAAE;MACZhB,OAAO,CAACC,aAAa,GAAG,UAAU,IAAI,CAACc,OAAO,CAACC,QAAQ,EAAE;IAC3D;IACA,IAAIkJ,QAAQ;IACZ,IAAIxD,SAAS,GAAG,IAAI,CAAClF,MAAM,CAACyE,UAAU,CAACP,IAAI,CACxCa,IAAI,IAAKA,IAAI,CAAC5F,EAAE,KAAKkd,YACxB,CAAC;IACD,IAAI,CAAC/c,EAAE,GAAG4F,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAAC+T,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG3Z,EAAE,CAACoJ,QAAQ,EAAE;MACtFA,QAAQ,GAAGxD,SAAS,CAAC+T,KAAK,CAACvQ,QAAQ;IACrC,CAAC,MAAM;MACLA,QAAQ,GAAG,IAAI,CAAC1I,MAAM,CAACD,IAAI;IAC7B;IACA,IAAI4B,IAAI;IACR,IAAI,QAAQ,IAAIiE,IAAI,EAAE;MACpBjE,IAAI,GAAG,IAAIJ,QAAQ,CAAC,CAAC;MACrB,KAAK,MAAMlH,GAAG,IAAIuL,IAAI,CAACA,IAAI,EAAE;QAC3B,IAAIvL,GAAG,KAAK,QAAQ,EAClB;QACFsH,IAAI,CAACH,MAAM,CAACnH,GAAG,EAAEuL,IAAI,CAACA,IAAI,CAACvL,GAAG,CAAC,CAAC;MAClC;MACAsH,IAAI,CAACpG,GAAG,CAAC,cAAc,EAAE8gB,YAAY,CAACnZ,QAAQ,CAAC,CAAC,CAAC;MACjDvB,IAAI,CAACpG,GAAG,CAAC,SAAS,EAAE+gB,OAAO,CAAC;MAC5B3a,IAAI,CAACpG,GAAG,CAAC,cAAc,EAAEqZ,YAAY,CAAC;IACxC,CAAC,MAAM;MACLjT,IAAI,GAAGwG,IAAI,CAACC,SAAS,CAAC;QACpBxC,IAAI;QACJyW,YAAY;QACZC,OAAO;QACP1H;MACF,CAAC,CAAC;MACFpW,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;IAC9C;IACA,IAAIgB,QAAQ,EAAE;MACZhB,OAAO,CAACC,aAAa,GAAG,UAAUe,QAAQ,EAAE;IAC9C;IACA,IAAI;MACF,MAAMY,QAAQ,GAAG,MAAM,IAAI,CAAC7B,KAAK,CAAC,GAAGmK,QAAQ,oBAAoB,EAAE;QACjEhH,MAAM,EAAE,MAAM;QACdC,IAAI;QACJnD,OAAO;QACP6B,WAAW,EAAE;MACf,CAAC,CAAC;MACF,IAAI,CAACD,QAAQ,CAACmI,EAAE,EAAE;QAChB,MAAM,IAAI/H,KAAK,CACb,yCAAyC,GAAGJ,QAAQ,CAACkR,UACvD,CAAC;MACH;MACA,MAAMtK,MAAM,GAAG,MAAM5G,QAAQ,CAACxB,IAAI,CAAC,CAAC;MACpC,OAAOoI,MAAM;IACf,CAAC,CAAC,OAAOnI,CAAC,EAAE;MACV4G,OAAO,CAACgC,IAAI,CAAC5I,CAAC,CAAC;IACjB;EACF;EACAsC,WAAWA,CAACob,WAAW,EAAE;IACvB,IAAI,CAACle,OAAO,GAAG6D,qBAAqB,CAACqa,WAAW,CAAC,CAACjgB,IAAI,CAAC,IAAI,CAAC;EAC9D;EACA6f,kBAAkBA,CAAA,EAAG;IACnB,OAAO;MACLnc,MAAM,EAAE,IAAI,CAACA,MAAM;MACnB8O,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBM,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBpH,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBoU,gBAAgB,EAAE,IAAI,CAACA;IACzB,CAAC;EACH;AACF;AACA,eAAeI,MAAMA,CAACxb,aAAa,EAAEzB,OAAO,GAAG;EAC7C4T,MAAM,EAAE,CAAC,MAAM;AACjB,CAAC,EAAE;EACD,OAAO,MAAM/B,MAAM,CAACC,OAAO,CAACrQ,aAAa,EAAEzB,OAAO,CAAC;AACrD;AACA,eAAekd,eAAeA,CAACzb,aAAa,EAAEzB,OAAO,EAAE;EACrD,OAAO,MAAM6R,MAAM,CAACT,SAAS,CAAC3P,aAAa,EAAEzB,OAAO,CAAC;AACvD;AACA,SACE6R,MAAM,EACNnH,QAAQ,EACRuS,MAAM,EACNC,eAAe,IAAI9L,SAAS,EAC5B9D,WAAW,EACXiC,OAAO,EACP5E,aAAa,EACbkF,MAAM,EACNhG,MAAM,EACNX,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}