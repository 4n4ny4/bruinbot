{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, {\n  numeric: 1\n}).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = \"host\";\nconst UPLOAD_URL = \"upload\";\nconst LOGIN_URL = \"login\";\nconst CONFIG_URL = \"config\";\nconst API_INFO_URL = \"info\";\nconst RUNTIME_URL = \"runtime\";\nconst SLEEPTIME_URL = \"sleeptime\";\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...(cookies ? {\n          Cookie: cookies\n        } : {})\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(_ref => {\n    let {\n      api_name,\n      id\n    } = _ref;\n    if (api_name) apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? {\n    Authorization: `Bearer ${this.options.hf_token}`\n  } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return {\n      ...config,\n      path\n    };\n  } else if (endpoint) {\n    const config_url = join_urls(endpoint, CONFIG_URL);\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const {\n    http_protocol,\n    host\n  } = await process_endpoint(this.app_reference, this.options.hf_token);\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(http_protocol, host, this.options.auth, this.fetch, this.options.hf_token);\n      if (cookie_header) this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const {\n      protocol,\n      host,\n      pathname\n    } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst parse_and_set_cookies = cookie_header => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach(cookie => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(`https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`, {\n        headers\n      });\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const {\n      ws_protocol,\n      http_protocol,\n      host\n    } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = function () {\n  try {\n    for (var _len = arguments.length, urls = new Array(_len), _key = 0; _key < _len; _key++) {\n      urls[_key] = arguments[_key];\n    }\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach(category => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(_ref2 => {\n        let [endpoint, {\n          parameters,\n          returns\n        }] = _ref2;\n        var _a, _b, _c, _d;\n        const dependencyIndex = ((_a = config.dependencies.find(dep => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\"))) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n        const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find(dep => dep.id == dependencyIndex)) == null ? void 0 : _b.types : {\n          generator: false,\n          cancel: false\n        };\n        if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find(dep => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n          const components = config.dependencies.find(dep => dep.id == dependencyIndex).inputs.map(input => {\n            var _a2;\n            return (_a2 = config.components.find(c => c.id === input)) == null ? void 0 : _a2.type;\n          });\n          try {\n            components.forEach((comp, idx) => {\n              if (comp === \"state\") {\n                const new_param = {\n                  component: \"state\",\n                  example: null,\n                  parameter_default: null,\n                  parameter_has_default: true,\n                  parameter_name: null,\n                  hidden: true\n                };\n                parameters.splice(idx, 0, new_param);\n              }\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        }\n        const transform_type = (data, component, serializer, signature_type) => ({\n          ...data,\n          description: get_description(data == null ? void 0 : data.type, serializer),\n          type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n        });\n        transformed_info[category][endpoint] = {\n          parameters: parameters.map(p => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")),\n          returns: returns.map(r => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")),\n          type: dependencyTypes\n        };\n      });\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return {\n        type: \"data\"\n      };\n    case \"send_hash\":\n      return {\n        type: \"hash\"\n      };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return {\n        type: \"log\",\n        data\n      };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return {\n    type: \"none\",\n    status: {\n      stage: \"error\",\n      queue\n    }\n  };\n}\nconst map_data_to_params = function () {\n  let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let endpoint_info = arguments.length > 1 ? arguments[1] : undefined;\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(`No value provided for required parameter: ${param.parameter_name}`);\n    }\n  });\n  provided_keys.forEach(key => {\n    if (!parameters.some(param => param.parameter_name === key)) {\n      throw new Error(`Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`);\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(`No value provided for required parameter: ${parameters[idx].parameter_name}`);\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info) return this.api_info;\n  const {\n    hf_token\n  } = this.options;\n  const {\n    config\n  } = this;\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    \"Could not get API info. \" + e.message;\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach(file => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return {\n        error: `HTTP ${response.status}: ${error_text}`\n      };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return {\n    files: uploadResponses\n  };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(file_data2 => file_data2.blob);\n  const oversized_files = files.filter(f => f.size > (max_file_size ?? Infinity));\n  if (oversized_files.length) {\n    throw new Error(`File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map(f => f.name).join(\", \")}`);\n  }\n  return await Promise.all(await this.upload_files(root_url, files, upload_id).then(async response => {\n    if (response.error) {\n      throw new Error(response.error);\n    } else {\n      if (response.files) {\n        return response.files.map((f, i) => {\n          const file = new FileData({\n            ...file_data[i],\n            path: f,\n            url: root_url + \"/file=\" + f\n          });\n          return file;\n        });\n      }\n      return [];\n    }\n  }));\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(f => new FileData({\n    path: f.name,\n    orig_name: f.name,\n    blob: f,\n    size: f.size,\n    mime_type: f.type,\n    is_stream\n  }));\n}\nclass FileData {\n  constructor(_ref3) {\n    let {\n      path,\n      url,\n      orig_name,\n      size,\n      blob,\n      is_stream,\n      mime_type,\n      alt_text\n    } = _ref3;\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"meta\", {\n      _type: \"gradio.FileData\"\n    });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data) {\n  let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let endpoint_info = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(data.map(async (_, index) => {\n      var _a;\n      let new_path = path.slice();\n      new_path.push(String(index));\n      const array_refs = await walk_and_store_blobs(data[index], root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type, new_path, false, endpoint_info);\n      blob_refs = blob_refs.concat(array_refs);\n    }));\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [{\n      path,\n      blob: new Blob([data]),\n      type\n    }];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(await walk_and_store_blobs(value, void 0, new_path, false, endpoint_info));\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find(dep => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = _ref4 => {\n      let {\n        data\n      } = _ref4;\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: {\n          _type: \"gradio.FileData\"\n        }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\"Invalid input: must be a URL, File, Blob, or Buffer object.\");\n}\nfunction handle_payload(resolved_payload, dependency, components, type) {\n  let with_null_state = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find(c => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(data, void 0, [], true, api_info);\n  const results = await Promise.all(blobRefs.map(async _ref5 => {\n    let {\n      path,\n      blob,\n      type\n    } = _ref5;\n    if (!blob) return {\n      path,\n      type\n    };\n    const response = await self.upload_files(endpoint, [blob]);\n    const file_url = response.files && response.files[0];\n    return {\n      path,\n      file_url,\n      type,\n      name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n    };\n  }));\n  results.forEach(_ref6 => {\n    let {\n      path,\n      file_url,\n      type,\n      name\n    } = _ref6;\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({\n        path: file_url,\n        orig_name: name\n      });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data) {\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await import(\"fs/promises\");\n      const path = await import(\"path\");\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], {\n      type: \"application/octet-stream\"\n    });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: {\n        ...headers,\n        ...additional_headers\n      },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{\n      error: BROKEN_CONNECTION_MSG\n    }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = {\n      error: `Could not parse server response: ${e}`\n    };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find(dep => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(dep => dep.id == this.api_map[trimmed_endpoint]);\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\") reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200) return;\n  const {\n    runtime: {\n      stage\n    },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise(resolve => {\n    check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", status => {\n      status_callback(status);\n      if (status.status === \"running\") {\n        resolve();\n      } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n        resolve();\n      } else if (status.status === \"sleeping\" || status.status === \"building\") {\n        if (retries < max_retries) {\n          retries++;\n          setTimeout(() => {\n            check_and_wake_space(space_id, status_callback).then(resolve);\n          }, check_interval);\n        } else {\n          resolve();\n        }\n      }\n    });\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space_id}/discussions`, {\n      method: \"HEAD\"\n    });\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error)) return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`, {\n      headers\n    });\n    if (res.status !== 200) throw new Error(\"Space hardware could not be obtained.\");\n    const {\n      hardware\n    } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(body)\n    });\n    if (res.status !== 200) {\n      throw new Error(\"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\");\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\"cpu-basic\", \"cpu-upgrade\", \"cpu-xl\", \"t4-small\", \"t4-medium\", \"a10g-small\", \"a10g-large\", \"a10g-largex2\", \"a10g-largex4\", \"a100-large\", \"zero-a10g\", \"h100\", \"h100x8\"];\nasync function duplicate(app_reference, options) {\n  const {\n    hf_token,\n    private: _private,\n    hardware,\n    timeout,\n    auth\n  } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(`Invalid hardware type provided. Valid types are: ${hardware_types.map(v => `\"${v}\"`).join(\",\")}.`);\n  }\n  const {\n    http_protocol,\n    host\n  } = await process_endpoint(app_reference, hf_token);\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(http_protocol, host, auth, fetch);\n    if (cookie_header) cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...(cookies ? {\n      Cookie: cookies.join(\"; \")\n    } : {})\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(`https://huggingface.co/api/spaces/${app_reference}/duplicate`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body)\n    });\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(get_space_reference(duplicated_space.url), options);\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      allowCR: false\n    };\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1) break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: controller => {\n        if (__privateGet(this, _currentLine) === \"\") return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({\n    allowCR: true\n  });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [input.substring(0, idx), input.substring(idx + match[0].length)];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp) headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body) return;\n  let iter = stream$1(res.body);\n  let line,\n    reader = iter.getReader();\n  let event;\n  for (;;) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done) return;\n    if (!line.value) {\n      if (event) yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field) continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok) throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}/queue/data?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function (event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(Object.keys(event_callbacks).map(event_id2 => event_callbacks[event_id2](_data)));\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(config.protocol)) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function () {\n    await Promise.all(Object.keys(event_callbacks).map(event_id => event_callbacks[event_id]({\n      msg: \"unexpected_error\",\n      message: BROKEN_CONNECTION_MSG\n    })));\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(_ref7 => {\n    let [action, path, value] = _ref7;\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input) {\n  let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async res => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch(e => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let event_data = arguments.length > 2 ? arguments[2] : undefined;\n  let trigger_id = arguments.length > 3 ? arguments[3] : undefined;\n  let all_events = arguments.length > 4 ? arguments[4] : undefined;\n  var _a;\n  try {\n    let fire_event = function (event) {\n        if (all_events || events_to_publish[event.type]) {\n          push_event(event);\n        }\n      },\n      close = function () {\n        done = true;\n        while (resolvers.length > 0) resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n      },\n      push = function (data2) {\n        if (done) return;\n        if (resolvers.length > 0) {\n          resolvers.shift()(data2);\n        } else {\n          values.push(data2);\n        }\n      },\n      push_error = function (error) {\n        push(thenable_reject(error));\n        close();\n      },\n      push_event = function (event) {\n        push({\n          value: event,\n          done: false\n        });\n      },\n      next = function () {\n        if (values.length > 0) return Promise.resolve(values.shift());\n        if (done) return Promise.resolve({\n          value: void 0,\n          done: true\n        });\n        return new Promise(resolve => resolvers.push(resolve));\n      };\n    const {\n      hf_token\n    } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options\n    } = this;\n    const that = this;\n    if (!api_info) throw new Error(\"No API found\");\n    if (!config) throw new Error(\"Could not resolve app config\");\n    let {\n      fn_index,\n      endpoint_info,\n      dependency\n    } = get_endpoint_info(api_info, endpoint, api_map, config);\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce((acc, event) => {\n      acc[event] = true;\n      return acc;\n    }, {})) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = {\n          fn_index,\n          session_hash\n        };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = {\n          event_id\n        };\n        cancel_request = {\n          event_id,\n          session_hash,\n          fn_index\n        };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}/cancel`, {\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}/reset`, {\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\");\n      }\n    }\n    const resolve_heartbeat = async config2 => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config) return;\n      let render_id = render_config.render_id;\n      config.components = [...config.components.filter(c => c.props.rendered_in !== render_id), ...render_config.components];\n      config.dependencies = [...config.dependencies.filter(d => d.rendered_in !== render_id), ...render_config.dependencies];\n      const any_state = config.components.some(c => c.type === \"state\");\n      const any_unload = config.dependencies.some(d => d.targets.some(t => t[1] === \"unload\"));\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(async _payload => {\n      var _a2;\n      let input_data = handle_payload(_payload, dependency, config.components, \"input\", true);\n      payload = {\n        data: input_data || [],\n        event_data,\n        fn_index,\n        trigger_id\n      };\n      if (skip_queue(fn_index, config)) {\n        fire_event({\n          type: \"status\",\n          endpoint: _endpoint,\n          stage: \"pending\",\n          queue: false,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        post_data2(`${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`, {\n          ...payload,\n          session_hash\n        }).then(_ref8 => {\n          let [output, status_code] = _ref8;\n          const data2 = output.data;\n          if (status_code == 200) {\n            fire_event({\n              type: \"data\",\n              endpoint: _endpoint,\n              fn_index,\n              data: handle_payload(data2, dependency, config.components, \"output\", options.with_null_state),\n              time: /* @__PURE__ */new Date(),\n              event_data,\n              trigger_id\n            });\n            if (output.render_config) {\n              handle_render_config(output.render_config);\n            }\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              stage: \"complete\",\n              eta: output.average_duration,\n              queue: false,\n              time: /* @__PURE__ */new Date()\n            });\n          } else {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              endpoint: _endpoint,\n              fn_index,\n              message: output.error,\n              queue: false,\n              time: /* @__PURE__ */new Date()\n            });\n          }\n        }).catch(e => {\n          fire_event({\n            type: \"status\",\n            stage: \"error\",\n            message: e.message,\n            endpoint: _endpoint,\n            fn_index,\n            queue: false,\n            time: /* @__PURE__ */new Date()\n          });\n        });\n      } else if (protocol == \"ws\") {\n        const {\n          ws_protocol,\n          host\n        } = await process_endpoint(app_reference, hf_token);\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        let url = new URL(`${ws_protocol}://${resolve_root(host, config.path, true)}/queue/join${url_params ? \"?\" + url_params : \"\"}`);\n        if (this.jwt) {\n          url.searchParams.set(\"__sign\", this.jwt);\n        }\n        websocket = new WebSocket(url);\n        websocket.onclose = evt => {\n          if (!evt.wasClean) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              broken: true,\n              message: BROKEN_CONNECTION_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          }\n        };\n        websocket.onmessage = function (event) {\n          const _data = JSON.parse(event.data);\n          const {\n            type,\n            status,\n            data: data2\n          } = handle_message(_data, last_status[fn_index]);\n          if (type === \"update\" && status && !complete) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date(),\n              ...status\n            });\n            if (status.stage === \"error\") {\n              websocket.close();\n            }\n          } else if (type === \"hash\") {\n            websocket.send(JSON.stringify({\n              fn_index,\n              session_hash\n            }));\n            return;\n          } else if (type === \"data\") {\n            websocket.send(JSON.stringify({\n              ...payload,\n              session_hash\n            }));\n          } else if (type === \"complete\") {\n            complete = status;\n          } else if (type === \"log\") {\n            fire_event({\n              type: \"log\",\n              log: data2.log,\n              level: data2.level,\n              endpoint: _endpoint,\n              duration: data2.duration,\n              visible: data2.visible,\n              fn_index\n            });\n          } else if (type === \"generating\") {\n            fire_event({\n              type: \"status\",\n              time: /* @__PURE__ */new Date(),\n              ...status,\n              stage: status == null ? void 0 : status.stage,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index\n            });\n          }\n          if (data2) {\n            fire_event({\n              type: \"data\",\n              time: /* @__PURE__ */new Date(),\n              data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n              endpoint: _endpoint,\n              fn_index,\n              event_data,\n              trigger_id\n            });\n            if (complete) {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */new Date(),\n                ...complete,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n              websocket.close();\n            }\n          }\n        };\n        if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n          addEventListener(\"open\", () => websocket.send(JSON.stringify({\n            hash: session_hash\n          })));\n        }\n      } else if (protocol == \"sse\") {\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        var params = new URLSearchParams({\n          fn_index: fn_index.toString(),\n          session_hash\n        }).toString();\n        let url = new URL(`${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`);\n        if (this.jwt) {\n          url.searchParams.set(\"__sign\", this.jwt);\n        }\n        stream2 = this.stream(url);\n        if (!stream2) {\n          return Promise.reject(new Error(\"Cannot connect to SSE endpoint: \" + url.toString()));\n        }\n        stream2.onmessage = async function (event) {\n          const _data = JSON.parse(event.data);\n          const {\n            type,\n            status,\n            data: data2\n          } = handle_message(_data, last_status[fn_index]);\n          if (type === \"update\" && status && !complete) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date(),\n              ...status\n            });\n            if (status.stage === \"error\") {\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          } else if (type === \"data\") {\n            event_id = _data.event_id;\n            let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n              ...payload,\n              session_hash,\n              event_id\n            });\n            if (status2 !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */new Date()\n              });\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          } else if (type === \"complete\") {\n            complete = status;\n          } else if (type === \"log\") {\n            fire_event({\n              type: \"log\",\n              log: data2.log,\n              level: data2.level,\n              endpoint: _endpoint,\n              duration: data2.duration,\n              visible: data2.visible,\n              fn_index\n            });\n          } else if (type === \"generating\") {\n            fire_event({\n              type: \"status\",\n              time: /* @__PURE__ */new Date(),\n              ...status,\n              stage: status == null ? void 0 : status.stage,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index\n            });\n          }\n          if (data2) {\n            fire_event({\n              type: \"data\",\n              time: /* @__PURE__ */new Date(),\n              data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n              endpoint: _endpoint,\n              fn_index,\n              event_data,\n              trigger_id\n            });\n            if (complete) {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */new Date(),\n                ...complete,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          }\n        };\n      } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        let hostname = \"\";\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n          hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n        }\n        let hfhubdev = \"dev.spaces.huggingface.tech\";\n        const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n        const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\n        const is_zerogpu_space = dependency.zerogpu && config.space_id;\n        const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n        const post_data_promise = zerogpu_auth_promise.then(headers => {\n          return post_data2(`${config.root}/queue/join?${url_params}`, {\n            ...payload,\n            session_hash\n          }, headers);\n        });\n        post_data_promise.then(async _ref9 => {\n          let [response, status] = _ref9;\n          if (status === 503) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: QUEUE_FULL_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          } else if (status !== 200) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: BROKEN_CONNECTION_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          } else {\n            event_id = response.event_id;\n            let callback = async function (_data) {\n              try {\n                const {\n                  type,\n                  status: status2,\n                  data: data2\n                } = handle_message(_data, last_status[fn_index]);\n                if (type == \"heartbeat\") {\n                  return;\n                }\n                if (type === \"update\" && status2 && !complete) {\n                  fire_event({\n                    type: \"status\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date(),\n                    ...status2\n                  });\n                } else if (type === \"complete\") {\n                  complete = status2;\n                } else if (type == \"unexpected_error\") {\n                  console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date()\n                  });\n                } else if (type === \"log\") {\n                  fire_event({\n                    type: \"log\",\n                    log: data2.log,\n                    level: data2.level,\n                    endpoint: _endpoint,\n                    duration: data2.duration,\n                    visible: data2.visible,\n                    fn_index\n                  });\n                  return;\n                } else if (type === \"generating\") {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */new Date(),\n                    ...status2,\n                    stage: status2 == null ? void 0 : status2.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (data2 && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    apply_diff_stream(pending_diff_streams, event_id, data2);\n                  }\n                }\n                if (data2) {\n                  fire_event({\n                    type: \"data\",\n                    time: /* @__PURE__ */new Date(),\n                    data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (data2.render_config) {\n                    await handle_render_config(data2.render_config);\n                  }\n                  if (complete) {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */new Date(),\n                      ...complete,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    close();\n                  }\n                }\n                if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                  if (event_callbacks[event_id]) {\n                    delete event_callbacks[event_id];\n                  }\n                  if (event_id in pending_diff_streams) {\n                    delete pending_diff_streams[event_id];\n                  }\n                }\n              } catch (e) {\n                console.error(\"Unexpected client exception\", e);\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: \"An Unexpected Error Occurred!\",\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date()\n                });\n                if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                  close_stream(stream_status, that.abort_controller);\n                  stream_status.open = false;\n                  close();\n                }\n              }\n            };\n            if (event_id in pending_stream_messages) {\n              pending_stream_messages[event_id].forEach(msg => callback(msg));\n              delete pending_stream_messages[event_id];\n            }\n            event_callbacks[event_id] = callback;\n            unclosed_events.add(event_id);\n            if (!stream_status.open) {\n              await this.open_stream();\n            }\n          }\n        });\n      }\n    });\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async value => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find(dep => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(dep => dep.id == api_map[trimmed_endpoint]);\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\"There is no endpoint matching that name of fn_index matching that number.\");\n  }\n  return {\n    fn_index,\n    endpoint_info,\n    dependency\n  };\n}\nclass Client {\n  constructor(app_reference) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      events: [\"data\"]\n    };\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", {\n      open: false\n    });\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    this.app_reference = app_reference;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    return fetch(input, {\n      ...init,\n      headers\n    });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await import(\"./wrapper-CviSselG.js\");\n      global.WebSocket = ws.WebSocket;\n    }\n    try {\n      if (this.options.auth) {\n        await this.resolve_cookies();\n      }\n      await this._resolve_config().then(_ref10 => {\n        let {\n          config\n        } = _ref10;\n        return this._resolve_hearbeat(config);\n      });\n    } catch (e) {\n      throw Error(e);\n    }\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(this.config.space_id, this.options.hf_token, this.cookies);\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(`${this.config.root}/heartbeat/${this.session_hash}`);\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      events: [\"data\"]\n    };\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  static async duplicate(app_reference) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      events: [\"data\"]\n    };\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const {\n      http_protocol,\n      host,\n      space_id\n    } = await process_endpoint(this.app_reference, this.options.hf_token);\n    const {\n      status_callback\n    } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      config = await this.resolve_config(`${http_protocol}//${host}`);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", this.handle_space_success);\n      } else {\n        if (status_callback) status_callback({\n          status: \"error\",\n          message: \"Could not load this space.\",\n          load_status: \"error\",\n          detail: \"NOT_FOUND\"\n        });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const {\n      status_callback\n    } = this.options;\n    if (status_callback) status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const {\n      hf_token\n    } = this.options;\n    const {\n      session_hash\n    } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(comp => comp.id === component_id);\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\") continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(`${root_url}/component_server/`, {\n        method: \"POST\",\n        body,\n        headers,\n        credentials: \"include\"\n      });\n      if (!response.ok) {\n        throw new Error(\"Could not connect to component server: \" + response.statusText);\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n}\nasync function client(app_reference) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    events: [\"data\"]\n  };\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\nexport { Client, FileData, client, duplicate_space as duplicate, handle_file, predict, prepare_files, submit, upload, upload_files };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","__accessCheck","member","msg","has","TypeError","__privateGet","getter","call","get","__privateAdd","WeakSet","add","set","__privateSet","setter","_currentLine","fn","Intl","Collator","numeric","compare","semiver","a","b","bool","split","slice","join","test","HOST_URL","UPLOAD_URL","LOGIN_URL","CONFIG_URL","API_INFO_URL","RUNTIME_URL","SLEEPTIME_URL","SPACE_FETCHER_URL","QUEUE_FULL_MSG","BROKEN_CONNECTION_MSG","CONFIG_ERROR_MSG","SPACE_STATUS_ERROR_MSG","API_INFO_ERROR_MSG","SPACE_METADATA_ERROR_MSG","INVALID_URL_MSG","UNAUTHORIZED_MSG","INVALID_CREDENTIALS_MSG","MISSING_CREDENTIALS_MSG","NODEJS_FS_ERROR_MSG","ROOT_URL_ERROR_MSG","FILE_PROCESSING_ERROR_MSG","resolve_root","base_url","root_path","prioritize_base","startsWith","get_jwt","space","token","cookies","r","fetch","headers","Authorization","Cookie","jwt","json","e","map_names_to_ids","fns","apis","forEach","_ref","api_name","id","resolve_config","endpoint","_a","options","hf_token","window","gradio_config","location","origin","dev_mode","path","root","config","config_root","config_url","join_urls","response","credentials","status","auth","Error","dependencies","dep","i","resolve_cookies","http_protocol","host","process_endpoint","app_reference","cookie_header","get_cookie_header","set_cookies","message","_fetch","formData","FormData","append","res","method","body","determine_protocol","protocol","pathname","URL","endsWith","ws_protocol","parse_and_set_cookies","parts","cookie","cookie_name","cookie_value","push","trim","RE_SPACE_NAME","RE_SPACE_DOMAIN","_app_reference","replace","_host","space_id","_len","arguments","length","urls","Array","_key","reduce","part","toString","transform_api_info","api_info","api_map","transformed_info","named_endpoints","unnamed_endpoints","keys","category","entries","_ref2","parameters","returns","_b","_c","_d","dependencyIndex","find","dependencyTypes","types","generator","cancel","inputs","components","map","input","_a2","c","type","comp","idx","new_param","component","example","parameter_default","parameter_has_default","parameter_name","hidden","splice","console","error","transform_type","data","serializer","signature_type","description","get_description","get_type","p","handle_message","last_status","queue","stage","code","success","size","queue_size","position","rank","eta","rank_eta","progress_data","output","average_duration","visible","duration","changed_state_ids","map_data_to_params","undefined","endpoint_info","isArray","warn","resolved_data","provided_keys","param","index","hasOwnProperty","some","view_api","gradio_api_info","version","JSON","stringify","serialize","url","ok","api","upload_files","root_url","files","upload_id","chunkSize","uploadResponses","chunk","file","upload_url","error_text","text","upload","file_data","max_file_size","file_data2","blob","oversized_files","filter","f","Infinity","name","Promise","all","then","FileData","prepare_files","is_stream","orig_name","mime_type","constructor","_ref3","alt_text","_type","Command","command","meta","is_node","process","versions","node","update_object","object","newValue","stack","key2","shift","walk_and_store_blobs","blob_refs","_","new_path","String","array_refs","concat","globalThis","Buffer","Blob","skip_queue","fn_queue","enable_queue","post_message","_rej","channel","MessageChannel","port1","onmessage","_ref4","close","parent","postMessage","port2","handle_file","file_or_url","pop","orig_path","File","handle_payload","resolved_payload","dependency","with_null_state","updated_payload","payload_index","deps","outputs","input_id","handle_blob","self","process_local_file_commands","blobRefs","results","_ref5","file_url","_ref6","client2","recursively_process_commands","process_single_command","cmd_item","fileBuffer","fullPath","fs","resolve","cwd","readFile","fileData","post_data","additional_headers","predict","data_returned","status_complete","trimmed_endpoint","reject","app","submit","result","check_space_status","status_callback","_status","load_status","detail","runtime","space_name","setTimeout","discussions_enabled","check_and_wake_space","retries","max_retries","check_interval","RE_DISABLED_DISCUSSION","get_space_hardware","hardware","current","set_space_timeout","timeout","seconds","hardware_types","duplicate","private","_private","includes","v","user","repository","original_hardware","requested_hardware","Client","connect","statusText","duplicated_space","get_space_reference","regex","match","TextLineStream","TransformStream","allowCR","transform","chars","controller","lfIndex","indexOf","crIndex","enqueue","endIndex","flush","currentLine","WeakMap","stream$1","decoder","TextDecoderStream","split2","pipeThrough","rgx","exec","substring","fallback","tmp","events","signal","iter","line","reader","getReader","event","aborted","read","done","field","stream","init","req","Request","open_stream","event_callbacks","unclosed_events","pending_stream_messages","stream_status","that","open","stream2","params","URLSearchParams","session_hash","searchParams","_data","parse","close_stream","abort_controller","event_id","event_id2","delete","fn2","document","onerror","abort","apply_diff_stream","pending_diff_streams","is_first_generation","new_data","apply_diff","diff","_ref7","action","apply_edit","target","last_path","Number","readable_stream","instance","onopen","readyState","withCredentials","CONNECTING","OPEN","CLOSED","addEventListener","dispatchEvent","removeEventListener","catch","event_data","trigger_id","all_events","fire_event","events_to_publish","push_event","resolvers","data2","values","push_error","thenable_reject","next","fetch2","post_data2","fn_index","get_endpoint_info","websocket","_endpoint","payload","complete","url_params","search","acc","time","Date","reset_request","cancel_request","resolve_heartbeat","config2","_resolve_hearbeat","handle_render_config","render_config","render_id","props","rendered_in","d","any_state","any_unload","targets","t","connect_heartbeat","_payload","input_data","_ref8","status_code","WebSocket","onclose","evt","wasClean","broken","send","log","level","hash","status2","hostname","hfhubdev","is_iframe","is_zerogpu_space","zerogpu","zerogpu_auth_promise","post_data_promise","_ref9","callback","iterator","Symbol","asyncIterator","throw","return","Math","random","Set","bind","handle_space_success","Headers","AbortController","stream_instance","global","ws","_resolve_config","_ref10","_config","heartbeat_url","heartbeat_event","config_success","auth_required","prepare_return_obj","component_server","component_id","fn_name","raw_cookies","client","duplicate_space"],"sources":["/Users/ananyaanand/Desktop/bruinbot/node_modules/@gradio/client/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, { numeric: 1 }).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = \"host\";\nconst UPLOAD_URL = \"upload\";\nconst LOGIN_URL = \"login\";\nconst CONFIG_URL = \"config\";\nconst API_INFO_URL = \"info\";\nconst RUNTIME_URL = \"runtime\";\nconst SLEEPTIME_URL = \"sleeptime\";\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...cookies ? { Cookie: cookies } : {}\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({ api_name, id }) => {\n    if (api_name)\n      apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return { ...config, path };\n  } else if (endpoint) {\n    const config_url = join_urls(endpoint, CONFIG_URL);\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const { http_protocol, host } = await process_endpoint(\n    this.app_reference,\n    this.options.hf_token\n  );\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(\n        http_protocol,\n        host,\n        this.options.auth,\n        this.fetch,\n        this.options.hf_token\n      );\n      if (cookie_header)\n        this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const { protocol, host, pathname } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: endpoint\n  };\n}\nconst parse_and_set_cookies = (cookie_header) => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach((cookie) => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(\n        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,\n        { headers }\n      );\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach((category) => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(\n        ([endpoint, { parameters, returns }]) => {\n          var _a, _b, _c, _d;\n          const dependencyIndex = ((_a = config.dependencies.find(\n            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\")\n          )) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };\n          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(\n              (input) => {\n                var _a2;\n                return (_a2 = config.components.find((c) => c.id === input)) == null ? void 0 : _a2.type;\n              }\n            );\n            try {\n              components.forEach((comp, idx) => {\n                if (comp === \"state\") {\n                  const new_param = {\n                    component: \"state\",\n                    example: null,\n                    parameter_default: null,\n                    parameter_has_default: true,\n                    parameter_name: null,\n                    hidden: true\n                  };\n                  parameters.splice(idx, 0, new_param);\n                }\n              });\n            } catch (e) {\n              console.error(e);\n            }\n          }\n          const transform_type = (data, component, serializer, signature_type) => ({\n            ...data,\n            description: get_description(data == null ? void 0 : data.type, serializer),\n            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n          });\n          transformed_info[category][endpoint] = {\n            parameters: parameters.map(\n              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")\n            ),\n            returns: returns.map(\n              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")\n            ),\n            type: dependencyTypes\n          };\n        }\n      );\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return { type: \"data\" };\n    case \"send_hash\":\n      return { type: \"hash\" };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return { type: \"log\", data };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        }\n      };\n  }\n  return { type: \"none\", status: { stage: \"error\", queue } };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(\n        `No value provided for required parameter: ${param.parameter_name}`\n      );\n    }\n  });\n  provided_keys.forEach((key) => {\n    if (!parameters.some((param) => param.parameter_name === key)) {\n      throw new Error(\n        `Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`\n      );\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(\n        `No value provided for required parameter: ${parameters[idx].parameter_name}`\n      );\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info)\n    return this.api_info;\n  const { hf_token } = this.options;\n  const { config } = this;\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    \"Could not get API info. \" + e.message;\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach((file) => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return { error: `HTTP ${response.status}: ${error_text}` };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return { files: uploadResponses };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\n    (file_data2) => file_data2.blob\n  );\n  const oversized_files = files.filter(\n    (f) => f.size > (max_file_size ?? Infinity)\n  );\n  if (oversized_files.length) {\n    throw new Error(\n      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(\", \")}`\n    );\n  }\n  return await Promise.all(\n    await this.upload_files(root_url, files, upload_id).then(\n      async (response) => {\n        if (response.error) {\n          throw new Error(response.error);\n        } else {\n          if (response.files) {\n            return response.files.map((f, i) => {\n              const file = new FileData({\n                ...file_data[i],\n                path: f,\n                url: root_url + \"/file=\" + f\n              });\n              return file;\n            });\n          }\n          return [];\n        }\n      }\n    )\n  );\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(\n    (f) => new FileData({\n      path: f.name,\n      orig_name: f.name,\n      blob: f,\n      size: f.size,\n      mime_type: f.type,\n      is_stream\n    })\n  );\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"meta\", { _type: \"gradio.FileData\" });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(\n      data.map(async (_, index) => {\n        var _a;\n        let new_path = path.slice();\n        new_path.push(String(index));\n        const array_refs = await walk_and_store_blobs(\n          data[index],\n          root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type,\n          new_path,\n          false,\n          endpoint_info\n        );\n        blob_refs = blob_refs.concat(array_refs);\n      })\n    );\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [\n      {\n        path,\n        blob: new Blob([data]),\n        type\n      }\n    ];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(\n        await walk_and_store_blobs(\n          value,\n          void 0,\n          new_path,\n          false,\n          endpoint_info\n        )\n      );\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find((dep) => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({ data }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: { _type: \"gradio.FileData\" }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\n    \"Invalid input: must be a URL, File, Blob, or Buffer object.\"\n  );\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find((c) => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(\n    data,\n    void 0,\n    [],\n    true,\n    api_info\n  );\n  const results = await Promise.all(\n    blobRefs.map(async ({ path, blob, type }) => {\n      if (!blob)\n        return { path, type };\n      const response = await self.upload_files(endpoint, [blob]);\n      const file_url = response.files && response.files[0];\n      return {\n        path,\n        file_url,\n        type,\n        name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n      };\n    })\n  );\n  results.forEach(({ path, file_url, type, name }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({ path: file_url, orig_name: name });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await import(\"fs/promises\");\n      const path = await import(\"path\");\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], { type: \"application/octet-stream\" });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = { \"Content-Type\": \"application/json\" };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: { ...headers, ...additional_headers },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{ error: BROKEN_CONNECTION_MSG }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = { error: `Could not parse server response: ${e}` };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(\n      (dep) => dep.id == this.api_map[trimmed_endpoint]\n    );\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\")\n          reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200)\n    return;\n  const {\n    runtime: { stage },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise((resolve) => {\n    check_space_status(\n      space_id,\n      RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n      (status) => {\n        status_callback(status);\n        if (status.status === \"running\") {\n          resolve();\n        } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n          resolve();\n        } else if (status.status === \"sleeping\" || status.status === \"building\") {\n          if (retries < max_retries) {\n            retries++;\n            setTimeout(() => {\n              check_and_wake_space(space_id, status_callback).then(resolve);\n            }, check_interval);\n          } else {\n            resolve();\n          }\n        }\n      }\n    );\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\n      {\n        method: \"HEAD\"\n      }\n    );\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))\n      return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,\n      { headers }\n    );\n    if (res.status !== 200)\n      throw new Error(\"Space hardware could not be obtained.\");\n    const { hardware } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(\n      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,\n      {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify(body)\n      }\n    );\n    if (res.status !== 200) {\n      throw new Error(\n        \"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\"\n      );\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\n  \"cpu-basic\",\n  \"cpu-upgrade\",\n  \"cpu-xl\",\n  \"t4-small\",\n  \"t4-medium\",\n  \"a10g-small\",\n  \"a10g-large\",\n  \"a10g-largex2\",\n  \"a10g-largex4\",\n  \"a100-large\",\n  \"zero-a10g\",\n  \"h100\",\n  \"h100x8\"\n];\nasync function duplicate(app_reference, options) {\n  const { hf_token, private: _private, hardware, timeout, auth } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\n    );\n  }\n  const { http_protocol, host } = await process_endpoint(\n    app_reference,\n    hf_token\n  );\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(\n      http_protocol,\n      host,\n      auth,\n      fetch\n    );\n    if (cookie_header)\n      cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...cookies ? { Cookie: cookies.join(\"; \") } : {}\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\n      {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n      }\n    );\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(\n      get_space_reference(duplicated_space.url),\n      options\n    );\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = { allowCR: false }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1)\n            break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: (controller) => {\n        if (__privateGet(this, _currentLine) === \"\")\n          return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({ allowCR: true });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [\n      input.substring(0, idx),\n      input.substring(idx + match[0].length)\n    ];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp)\n    headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body)\n    return;\n  let iter = stream$1(res.body);\n  let line, reader = iter.getReader();\n  let event;\n  for (; ; ) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done)\n      return;\n    if (!line.value) {\n      if (event)\n        yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field)\n      continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok)\n    throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}/queue/data?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function(event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(\n        Object.keys(event_callbacks).map(\n          (event_id2) => event_callbacks[event_id2](_data)\n        )\n      );\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(\n        config.protocol\n      )) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function() {\n    await Promise.all(\n      Object.keys(event_callbacks).map(\n        (event_id) => event_callbacks[event_id]({\n          msg: \"unexpected_error\",\n          message: BROKEN_CONNECTION_MSG\n        })\n      )\n    );\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async (res) => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch((e) => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function(event) {\n      if (all_events || events_to_publish[event.type]) {\n        push_event(event);\n      }\n    }, close = function() {\n      done = true;\n      while (resolvers.length > 0)\n        resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n    }, push = function(data2) {\n      if (done)\n        return;\n      if (resolvers.length > 0) {\n        resolvers.shift()(data2);\n      } else {\n        values.push(data2);\n      }\n    }, push_error = function(error) {\n      push(thenable_reject(error));\n      close();\n    }, push_event = function(event) {\n      push({ value: event, done: false });\n    }, next = function() {\n      if (values.length > 0)\n        return Promise.resolve(values.shift());\n      if (done)\n        return Promise.resolve({ value: void 0, done: true });\n      return new Promise((resolve) => resolvers.push(resolve));\n    };\n    const { hf_token } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options\n    } = this;\n    const that = this;\n    if (!api_info)\n      throw new Error(\"No API found\");\n    if (!config)\n      throw new Error(\"Could not resolve app config\");\n    let { fn_index, endpoint_info, dependency } = get_endpoint_info(\n      api_info,\n      endpoint,\n      api_map,\n      config\n    );\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce(\n      (acc, event) => {\n        acc[event] = true;\n        return acc;\n      },\n      {}\n    )) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */ new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = { fn_index, session_hash };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = { event_id };\n        cancel_request = { event_id, session_hash, fn_index };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}/cancel`, {\n            headers: { \"Content-Type\": \"application/json\" },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}/reset`, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\n          \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\n        );\n      }\n    }\n    const resolve_heartbeat = async (config2) => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config)\n        return;\n      let render_id = render_config.render_id;\n      config.components = [\n        ...config.components.filter((c) => c.props.rendered_in !== render_id),\n        ...render_config.components\n      ];\n      config.dependencies = [\n        ...config.dependencies.filter((d) => d.rendered_in !== render_id),\n        ...render_config.dependencies\n      ];\n      const any_state = config.components.some((c) => c.type === \"state\");\n      const any_unload = config.dependencies.some(\n        (d) => d.targets.some((t) => t[1] === \"unload\")\n      );\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(\n      async (_payload) => {\n        var _a2;\n        let input_data = handle_payload(\n          _payload,\n          dependency,\n          config.components,\n          \"input\",\n          true\n        );\n        payload = {\n          data: input_data || [],\n          event_data,\n          fn_index,\n          trigger_id\n        };\n        if (skip_queue(fn_index, config)) {\n          fire_event({\n            type: \"status\",\n            endpoint: _endpoint,\n            stage: \"pending\",\n            queue: false,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          post_data2(\n            `${config.root}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\n            {\n              ...payload,\n              session_hash\n            }\n          ).then(([output, status_code]) => {\n            const data2 = output.data;\n            if (status_code == 200) {\n              fire_event({\n                type: \"data\",\n                endpoint: _endpoint,\n                fn_index,\n                data: handle_payload(\n                  data2,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                time: /* @__PURE__ */ new Date(),\n                event_data,\n                trigger_id\n              });\n              if (output.render_config) {\n                handle_render_config(output.render_config);\n              }\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                stage: \"complete\",\n                eta: output.average_duration,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                endpoint: _endpoint,\n                fn_index,\n                message: output.error,\n                queue: false,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          }).catch((e) => {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: e.message,\n              endpoint: _endpoint,\n              fn_index,\n              queue: false,\n              time: /* @__PURE__ */ new Date()\n            });\n          });\n        } else if (protocol == \"ws\") {\n          const { ws_protocol, host } = await process_endpoint(\n            app_reference,\n            hf_token\n          );\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let url = new URL(\n            `${ws_protocol}://${resolve_root(\n              host,\n              config.path,\n              true\n            )}/queue/join${url_params ? \"?\" + url_params : \"\"}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          websocket = new WebSocket(url);\n          websocket.onclose = (evt) => {\n            if (!evt.wasClean) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                broken: true,\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            }\n          };\n          websocket.onmessage = function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                websocket.close();\n              }\n            } else if (type === \"hash\") {\n              websocket.send(JSON.stringify({ fn_index, session_hash }));\n              return;\n            } else if (type === \"data\") {\n              websocket.send(JSON.stringify({ ...payload, session_hash }));\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                websocket.close();\n              }\n            }\n          };\n          if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n            addEventListener(\n              \"open\",\n              () => websocket.send(JSON.stringify({ hash: session_hash }))\n            );\n          }\n        } else if (protocol == \"sse\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          var params = new URLSearchParams({\n            fn_index: fn_index.toString(),\n            session_hash\n          }).toString();\n          let url = new URL(\n            `${config.root}/queue/join?${url_params ? url_params + \"&\" : \"\"}${params}`\n          );\n          if (this.jwt) {\n            url.searchParams.set(\"__sign\", this.jwt);\n          }\n          stream2 = this.stream(url);\n          if (!stream2) {\n            return Promise.reject(\n              new Error(\"Cannot connect to SSE endpoint: \" + url.toString())\n            );\n          }\n          stream2.onmessage = async function(event) {\n            const _data = JSON.parse(event.data);\n            const { type, status, data: data2 } = handle_message(\n              _data,\n              last_status[fn_index]\n            );\n            if (type === \"update\" && status && !complete) {\n              fire_event({\n                type: \"status\",\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date(),\n                ...status\n              });\n              if (status.stage === \"error\") {\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"data\") {\n              event_id = _data.event_id;\n              let [_, status2] = await post_data2(`${config.root}/queue/data`, {\n                ...payload,\n                session_hash,\n                event_id\n              });\n              if (status2 !== 200) {\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: BROKEN_CONNECTION_MSG,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */ new Date()\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            } else if (type === \"complete\") {\n              complete = status;\n            } else if (type === \"log\") {\n              fire_event({\n                type: \"log\",\n                log: data2.log,\n                level: data2.level,\n                endpoint: _endpoint,\n                duration: data2.duration,\n                visible: data2.visible,\n                fn_index\n              });\n            } else if (type === \"generating\") {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */ new Date(),\n                ...status,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n            }\n            if (data2) {\n              fire_event({\n                type: \"data\",\n                time: /* @__PURE__ */ new Date(),\n                data: handle_payload(\n                  data2.data,\n                  dependency,\n                  config.components,\n                  \"output\",\n                  options.with_null_state\n                ),\n                endpoint: _endpoint,\n                fn_index,\n                event_data,\n                trigger_id\n              });\n              if (complete) {\n                fire_event({\n                  type: \"status\",\n                  time: /* @__PURE__ */ new Date(),\n                  ...complete,\n                  stage: status == null ? void 0 : status.stage,\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index\n                });\n                stream2 == null ? void 0 : stream2.close();\n                close();\n              }\n            }\n          };\n        } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n          fire_event({\n            type: \"status\",\n            stage: \"pending\",\n            queue: true,\n            endpoint: _endpoint,\n            fn_index,\n            time: /* @__PURE__ */ new Date()\n          });\n          let hostname = \"\";\n          if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n            hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n          }\n          let hfhubdev = \"dev.spaces.huggingface.tech\";\n          const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n          const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\n          const is_zerogpu_space = dependency.zerogpu && config.space_id;\n          const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n          const post_data_promise = zerogpu_auth_promise.then((headers) => {\n            return post_data2(\n              `${config.root}/queue/join?${url_params}`,\n              {\n                ...payload,\n                session_hash\n              },\n              headers\n            );\n          });\n          post_data_promise.then(async ([response, status]) => {\n            if (status === 503) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: QUEUE_FULL_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else if (status !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */ new Date()\n              });\n            } else {\n              event_id = response.event_id;\n              let callback = async function(_data) {\n                try {\n                  const { type, status: status2, data: data2 } = handle_message(\n                    _data,\n                    last_status[fn_index]\n                  );\n                  if (type == \"heartbeat\") {\n                    return;\n                  }\n                  if (type === \"update\" && status2 && !complete) {\n                    fire_event({\n                      type: \"status\",\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2\n                    });\n                  } else if (type === \"complete\") {\n                    complete = status2;\n                  } else if (type == \"unexpected_error\") {\n                    console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                    fire_event({\n                      type: \"status\",\n                      stage: \"error\",\n                      message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index,\n                      time: /* @__PURE__ */ new Date()\n                    });\n                  } else if (type === \"log\") {\n                    fire_event({\n                      type: \"log\",\n                      log: data2.log,\n                      level: data2.level,\n                      endpoint: _endpoint,\n                      duration: data2.duration,\n                      visible: data2.visible,\n                      fn_index\n                    });\n                    return;\n                  } else if (type === \"generating\") {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */ new Date(),\n                      ...status2,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2 && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                      apply_diff_stream(pending_diff_streams, event_id, data2);\n                    }\n                  }\n                  if (data2) {\n                    fire_event({\n                      type: \"data\",\n                      time: /* @__PURE__ */ new Date(),\n                      data: handle_payload(\n                        data2.data,\n                        dependency,\n                        config.components,\n                        \"output\",\n                        options.with_null_state\n                      ),\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    if (data2.render_config) {\n                      await handle_render_config(data2.render_config);\n                    }\n                    if (complete) {\n                      fire_event({\n                        type: \"status\",\n                        time: /* @__PURE__ */ new Date(),\n                        ...complete,\n                        stage: status2 == null ? void 0 : status2.stage,\n                        queue: true,\n                        endpoint: _endpoint,\n                        fn_index\n                      });\n                      close();\n                    }\n                  }\n                  if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                    if (event_callbacks[event_id]) {\n                      delete event_callbacks[event_id];\n                    }\n                    if (event_id in pending_diff_streams) {\n                      delete pending_diff_streams[event_id];\n                    }\n                  }\n                } catch (e) {\n                  console.error(\"Unexpected client exception\", e);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */ new Date()\n                  });\n                  if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    close_stream(stream_status, that.abort_controller);\n                    stream_status.open = false;\n                    close();\n                  }\n                }\n              };\n              if (event_id in pending_stream_messages) {\n                pending_stream_messages[event_id].forEach(\n                  (msg) => callback(msg)\n                );\n                delete pending_stream_messages[event_id];\n              }\n              event_callbacks[event_id] = callback;\n              unclosed_events.add(event_id);\n              if (!stream_status.open) {\n                await this.open_stream();\n              }\n            }\n          });\n        }\n      }\n    );\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async (value) => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find((dep) => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(\n      (dep) => dep.id == api_map[trimmed_endpoint]\n    );\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\n      \"There is no endpoint matching that name of fn_index matching that number.\"\n    );\n  }\n  return { fn_index, endpoint_info, dependency };\n}\nclass Client {\n  constructor(app_reference, options = { events: [\"data\"] }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", { open: false });\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */ new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    this.app_reference = app_reference;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    return fetch(input, { ...init, headers });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await import(\"./wrapper-CviSselG.js\");\n      global.WebSocket = ws.WebSocket;\n    }\n    try {\n      if (this.options.auth) {\n        await this.resolve_cookies();\n      }\n      await this._resolve_config().then(\n        ({ config }) => this._resolve_hearbeat(config)\n      );\n    } catch (e) {\n      throw Error(e);\n    }\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(\n            this.config.space_id,\n            this.options.hf_token,\n            this.cookies\n          );\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(\n        `${this.config.root}/heartbeat/${this.session_hash}`\n      );\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const { http_protocol, host, space_id } = await process_endpoint(\n      this.app_reference,\n      this.options.hf_token\n    );\n    const { status_callback } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      config = await this.resolve_config(`${http_protocol}//${host}`);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(\n          space_id,\n          RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\n          this.handle_space_success\n        );\n      } else {\n        if (status_callback)\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const { status_callback } = this.options;\n    if (status_callback)\n      status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const { hf_token } = this.options;\n    const { session_hash } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(\n      (comp) => comp.id === component_id\n    );\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\")\n          continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(`${root_url}/component_server/`, {\n        method: \"POST\",\n        body,\n        headers,\n        credentials: \"include\"\n      });\n      if (!response.ok) {\n        throw new Error(\n          \"Could not connect to component server: \" + response.statusText\n        );\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\nexport {\n  Client,\n  FileData,\n  client,\n  duplicate_space as duplicate,\n  handle_file,\n  predict,\n  prepare_files,\n  submit,\n  upload,\n  upload_files\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}